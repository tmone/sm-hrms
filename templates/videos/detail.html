{% extends "base.html" %}

{% block title %}{{ video.filename }} - Video Details{% endblock %}

{% block head %}
{{ super() }}
<!-- Socket.IO Client -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
{% endblock %}

{% block content %}
<style>
/* Progress bar animations */
@keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.7; }
    100% { opacity: 1; }
}

@keyframes progressGlow {
    0% { box-shadow: 0 0 5px rgba(59, 130, 246, 0.5); }
    50% { box-shadow: 0 0 15px rgba(59, 130, 246, 0.8); }
    100% { box-shadow: 0 0 5px rgba(59, 130, 246, 0.5); }
}

.progress-bar-animated {
    animation: progressGlow 2s ease-in-out infinite;
}

.conversion-status-live {
    animation: pulse 2s infinite;
}

/* Live indicator */
@keyframes liveDot {
    0% { opacity: 0.3; transform: scale(0.8); }
    50% { opacity: 1; transform: scale(1.2); }
    100% { opacity: 0.3; transform: scale(0.8); }
}

.live-indicator {
    animation: liveDot 1.5s infinite;
}
</style>

<script>
// Define video handler functions early so they're available for inline event handlers
function handleVideoLoad() {
    console.log('Video loading started...');
    const loading = document.getElementById('videoLoading');
    const error = document.getElementById('videoError');
    if (loading) loading.classList.add('hidden');
    if (error) error.classList.add('hidden');
}

function handleVideoError() {
    console.log('‚ùå Video error occurred');
    const video = document.getElementById('videoPlayer');
    const error = document.getElementById('videoError');
    
    if (video && video.error) {
        console.error('Video error details:', {
            code: video.error.code,
            message: video.error.message,
            MEDIA_ERR_ABORTED: video.error.code === 1,
            MEDIA_ERR_NETWORK: video.error.code === 2,
            MEDIA_ERR_DECODE: video.error.code === 3,
            MEDIA_ERR_SRC_NOT_SUPPORTED: video.error.code === 4
        });
        
        // Try to get more info about the video
        const sources = video.querySelectorAll('source');
        sources.forEach((source, index) => {
            console.log(`Source ${index + 1}: ${source.src}`);
            console.log(`Type: ${source.type}`);
        });
    }
    
    if (error) {
        error.classList.remove('hidden');
    }
    if (video) {
        // Don't hide the video, might still be useful for debugging
        // video.style.display = 'none';
    }
}
</script>

<div class="container mx-auto px-4">
    <div class="max-w-6xl mx-auto">
        <!-- Header -->
        <div class="bg-white rounded-lg shadow-md p-6 mb-6" data-video-fps="{{ video.fps }}">
            <div class="flex justify-between items-start">
                <div>
                    <h1 class="text-2xl font-bold text-gray-800">{{ video.title or video.filename }}</h1>
                    <p class="text-gray-600 mt-1">{{ video.description or 'No description provided' }}</p>
                    <div class="flex items-center space-x-4 mt-2 text-sm text-gray-500">
                        <span>{{ (video.file_size / 1024 / 1024) | round(1) }} MB</span>
                        {% if video.duration %}
                            <span>{{ "%.1f"|format(video.duration) }} seconds</span>
                        {% endif %}
                        <span>Uploaded {{ video.created_at.strftime('%b %d, %Y at %H:%M') }}</span>
                    </div>
                </div>
                <div class="flex space-x-2">
                    <span class="inline-flex px-3 py-1 text-sm font-semibold rounded-full 
                          {% if video.status == 'completed' %}bg-green-100 text-green-800
                          {% elif video.status == 'processing' %}bg-yellow-100 text-yellow-800
                          {% elif video.status == 'failed' %}bg-red-100 text-red-800
                          {% else %}bg-gray-100 text-gray-800{% endif %}">
                        {{ video.status.title() }}
                    </span>
                    <a href="{{ url_for('videos.index') }}" 
                       class="px-4 py-2 border border-gray-300 rounded-md text-gray-700 hover:bg-gray-50">
                        Back to Videos
                    </a>
                </div>
            </div>
        </div>

        <!-- Main Content: Video Preview and Detection Navigator -->
        <div class="flex flex-col xl:flex-row gap-6">
            <!-- Video Player (Always Visible) -->
            <div class="xl:w-2/3">
                <div class="bg-white rounded-lg shadow-md p-6 sticky top-6">
                    <h2 class="text-lg font-semibold text-gray-800 mb-4">Video Preview</h2>
                    
                    <!-- Debug info -->
                    <div class="text-xs text-gray-500 mb-2">
                        Debug: annotated_video_path = "{{ video.annotated_video_path }}"
                        | processed_path = "{{ video.processed_path }}"
                        | file_path = "{{ video.file_path }}"
                        | status = "{{ video.status }}"
                        
                        {% if video.status == 'completed' and not video.annotated_video_path %}
                        <div class="mt-2">
                            <a href="{{ url_for('videos.fix_annotated_path', id=video.id) }}" 
                               class="inline-block px-3 py-1 bg-yellow-500 text-white text-xs rounded hover:bg-yellow-600">
                                üîß Fix Missing Detected Video Path
                            </a>
                        </div>
                        {% endif %}
                    </div>
                    
                    {% if video.annotated_video_path %}
                        <!-- Show annotated video with detections -->
                        <div class="bg-green-50 border border-green-200 rounded-lg p-3 mb-4">
                            <div class="flex items-center">
                                <svg class="w-5 h-5 text-green-500 mr-2" fill="currentColor" viewBox="0 0 20 20">
                                    <path d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                </svg>
                                <span class="text-green-700 font-medium">‚úÖ Person Detection Complete</span>
                                <span class="text-green-600 text-sm ml-2">(showing detected video with bounding boxes)</span>
                            </div>
                        </div>
                        <video id="videoPlayer" controls class="w-full rounded-lg" preload="metadata" 
                               data-original-width="{{ video.resolution.split('x')[0] if video.resolution else '' }}"
                               data-original-height="{{ video.resolution.split('x')[1] if video.resolution else '' }}"
                               data-video-type="detected"
                               data-video-path="{{ video.annotated_video_path }}">
                            <!-- Primary: Use the stream-detected endpoint -->
                            <source src="{{ url_for('videos.stream_detected_video', filename=video.annotated_video_path) }}" type="{{ 'video/x-msvideo' if video.annotated_video_path.endswith('.avi') else 'video/mp4' }}">
                            <!-- Fallback 1: Direct path -->
                            <source src="/processing/outputs/{{ video.annotated_video_path }}" type="{{ 'video/x-msvideo' if video.annotated_video_path.endswith('.avi') else 'video/mp4' }}">
                            <!-- Fallback 2: Try with .avi extension if .mp4 fails -->
                            {% if video.annotated_video_path.endswith('.mp4') %}
                            <source src="/processing/outputs/{{ video.annotated_video_path.replace('.mp4', '.avi') }}" type="video/x-msvideo">
                            {% endif %}
                            <!-- Fallback 3: Other endpoints -->
                            <source src="{{ url_for('videos.serve_detected_video', filename=video.annotated_video_path) }}" type="{{ 'video/x-msvideo' if video.annotated_video_path.endswith('.avi') else 'video/mp4' }}">
                            Your browser does not support the video tag.
                        </video>
                        <div class="mt-2 text-sm text-green-600 bg-green-50 p-2 rounded">
                            üéØ <strong>Detection Results:</strong> {{ total_detections }} person detections found
                            <br>üìÅ Person tracking data saved for face recognition processing
                            <br>üé¨ Playing detected video: {{ video.annotated_video_path }}
                        </div>
                    {% elif video.processed_path %}
                        <!-- Show converted video if available -->
                        <video id="videoPlayer" controls class="w-full rounded-lg" preload="metadata" 
                               data-original-width="{{ video.resolution.split('x')[0] if video.resolution else '' }}"
                               data-original-height="{{ video.resolution.split('x')[1] if video.resolution else '' }}" 
                               onloadstart="console.log('üé¨ Loading converted video:', '{{ video.processed_path }}')"
                               oncanplay="console.log('‚úÖ Converted video can play')" 
                               onerror="console.error('‚ùå Converted video error:', event.target.error)"
                               onloadedmetadata="console.log('üìä Video metadata loaded:', {duration: event.target.duration, width: event.target.videoWidth, height: event.target.videoHeight})">
                            <source src="{{ url_for('videos.stream_video', filename=video.processed_path) }}" type="video/mp4">
                            <source src="{{ url_for('videos.serve_video_static', filename=video.processed_path) }}" type="video/mp4">
                            Your browser does not support the video tag.
                        </video>
                        <div class="mt-2 text-sm text-green-600 bg-green-50 p-2 rounded">
                            ‚úÖ <strong>Converted Video:</strong> This video has been automatically converted to web-compatible MP4 format.
                        </div>
                    {% elif video.file_path and video.status in ['uploaded', 'completed', 'failed'] and not video.annotated_video_path %}
                        <div id="videoContainer">
                            <video id="videoPlayer" controls class="w-full rounded-lg" 
                                   data-original-width="{{ video.resolution.split('x')[0] if video.resolution else '' }}"
                                   data-original-height="{{ video.resolution.split('x')[1] if video.resolution else '' }}"
                                   onloadstart="handleVideoLoad()" onerror="handleVideoError()">
                                <source src="{{ url_for('videos.stream_video', filename=video.file_path) }}" type="video/mp4">
                                <source src="{{ url_for('videos.serve_video_static', filename=video.file_path) }}" type="video/mp4">
                                Your browser does not support the video tag.
                            </video>
                            
                            <!-- Video Loading/Error States -->
                            <div id="videoLoading" class="bg-gray-100 rounded-lg h-64 flex items-center justify-center hidden">
                                <div class="text-center">
                                    <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4"></div>
                                    <p class="text-gray-600">Loading video...</p>
                                </div>
                            </div>
                            
                            <div id="videoError" class="bg-red-50 border border-red-200 rounded-lg p-4 mt-4 hidden">
                                <h4 class="text-sm font-medium text-red-800 mb-2">üö´ Video Format Not Supported</h4>
                                <div class="text-sm text-red-600 mb-3">
                                    <p>This video file appears to be in IMKH format, which is not supported by web browsers.</p>
                                    <p class="mt-2"><strong>Solutions:</strong></p>
                                    <ul class="list-disc ml-4 mt-1">
                                        <li>Convert to MP4 format using FFmpeg</li>
                                        <li>Use VLC Media Player to view the original file</li>
                                        <li>Contact your video source provider for a web-compatible version</li>
                                    </ul>
                                </div>
                                <div class="space-y-2">
                                    <button onclick="showConversionInstructions()" class="text-sm bg-blue-600 text-white px-3 py-1 rounded hover:bg-blue-700">
                                        üìù Show Conversion Instructions
                                    </button>
                                    <a href="{{ url_for('videos.download_video', filename=video.file_path) }}" 
                                       class="text-sm bg-green-600 text-white px-3 py-1 rounded hover:bg-green-700 inline-block">
                                        üì• Download Original File
                                    </a>
                                    <button onclick="openDiagnosticTool()" class="text-sm bg-purple-600 text-white px-3 py-1 rounded hover:bg-purple-700">
                                        üîç Open Diagnostic Tool
                                    </button>
                                </div>
                            </div>
                            
                            <div id="conversionInstructions" class="bg-blue-50 border border-blue-200 rounded-lg p-4 mt-4 hidden">
                                <h4 class="text-sm font-medium text-blue-800 mb-2">üõ†Ô∏è Video Conversion Instructions</h4>
                                <div class="text-sm text-blue-700">
                                    <p class="mb-2"><strong>Option 1: Using FFmpeg (Recommended)</strong></p>
                                    <ol class="list-decimal ml-4 mb-3">
                                        <li>Install FFmpeg from <a href="https://ffmpeg.org/download.html" target="_blank" class="underline">ffmpeg.org</a></li>
                                        <li>Open command line in the video file directory</li>
                                        <li>Run: <code class="bg-gray-200 px-1 rounded">ffmpeg -i input.mp4 -c:v libx264 -c:a aac -preset medium -crf 23 output.mp4</code></li>
                                    </ol>
                                    
                                    <p class="mb-2"><strong>Option 2: Using Online Converters</strong></p>
                                    <ul class="list-disc ml-4 mb-3">
                                        <li>CloudConvert, Online-Convert, or similar services</li>
                                        <li>Upload your file and convert to MP4</li>
                                    </ul>
                                    
                                    <p class="mb-2"><strong>Option 3: Video Editing Software</strong></p>
                                    <ul class="list-disc ml-4">
                                        <li>VLC Media Player (free)</li>
                                        <li>HandBrake (free)</li>
                                        <li>Adobe Premiere, Final Cut Pro, etc.</li>
                                    </ul>
                                </div>
                                <button onclick="hideConversionInstructions()" class="text-sm bg-gray-600 text-white px-3 py-1 rounded hover:bg-gray-700 mt-2">
                                    Hide Instructions
                                </button>
                            </div>
                        </div>
                        
                        <!-- Video Information -->
                        <div class="mt-4 text-sm text-gray-600">
                            <p><strong>File:</strong> {{ video.filename }}</p>
                            <p><strong>Size:</strong> {{ (video.file_size / 1024 / 1024) | round(1) }} MB</p>
                            {% if video.duration %}
                                <p><strong>Duration:</strong> {{ "%.1f"|format(video.duration) }} seconds</p>
                            {% endif %}
                        </div>
                    {% else %}
                        <div class="bg-gray-100 rounded-lg h-64 flex items-center justify-center">
                            {% if video.status == 'processing' %}
                                <div class="text-center">
                                    <div class="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4"></div>
                                    <p class="text-gray-600 mb-4">Extracting persons from video...</p>
                                    
                                    <!-- Progress Bar -->
                                    <div class="max-w-md mx-auto">
                                        <div class="flex justify-between text-sm text-blue-600 mb-2">
                                            <span>Progress</span>
                                            <span id="processingPercent">0%</span>
                                        </div>
                                        <div class="w-full bg-blue-200 rounded-full h-3 overflow-hidden">
                                            <div id="processingProgressBar" class="bg-blue-600 h-3 rounded-full transition-all duration-300" style="width: 0%"></div>
                                        </div>
                                        <div class="text-sm text-blue-600 mt-2">
                                            <div id="processingMessage">Initializing person extraction...</div>
                                        </div>
                                    </div>
                                </div>
                            {% elif video.status == 'failed' %}
                                <div class="text-center">
                                    <svg class="mx-auto h-12 w-12 text-red-400 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                                    </svg>
                                    <p class="text-gray-600">Processing failed</p>
                                    <p class="text-sm text-red-600 mt-1">{{ video.error_message or 'Unknown error' }}</p>
                                </div>
                            {% elif video.file_path %}
                                <!-- Fallback: Show original video if no other conditions match -->
                                <div id="videoContainer">
                                    <video id="videoPlayer" controls class="w-full rounded-lg" 
                                           data-original-width="{{ video.resolution.split('x')[0] if video.resolution else '' }}"
                                           data-original-height="{{ video.resolution.split('x')[1] if video.resolution else '' }}"
                                           onloadstart="handleVideoLoad()" onerror="handleVideoError()">
                                        <source src="{{ url_for('videos.stream_video', filename=video.file_path) }}" type="video/mp4">
                                        <source src="{{ url_for('videos.serve_video_static', filename=video.file_path) }}" type="video/mp4">
                                        Your browser does not support the video tag.
                                    </video>
                                    <div class="mt-2 text-sm text-yellow-600 bg-yellow-50 p-2 rounded">
                                        ‚ö†Ô∏è <strong>Original Video:</strong> Showing original upload (Status: {{ video.status }})
                                    </div>
                                </div>
                            {% else %}
                                <div class="text-center">
                                    <svg class="mx-auto h-12 w-12 text-gray-400 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 002 2v8a2 2 0 002 2z"></path>
                                    </svg>
                                    <p class="text-gray-600">Video preview not available</p>
                                    <p class="text-sm text-gray-500 mt-2">
                                        Status: {{ video.status }}<br>
                                        File path: {{ video.file_path if video.file_path else 'No file path' }}<br>
                                        Processed path: {{ video.processed_path if video.processed_path else 'No processed path' }}<br>
                                        Annotated path: {{ video.annotated_video_path if video.annotated_video_path else 'No annotated path' }}
                                    </p>
                                </div>
                            {% endif %}
                        </div>
                    {% endif %}
                </div>

                <!-- Processing Details -->
                <div class="bg-white rounded-lg shadow-md p-6">
                    <h2 class="text-lg font-semibold text-gray-800 mb-4">Processing Details</h2>
                    
                    <div class="grid grid-cols-2 gap-4 mb-4">
                        <div>
                            <label class="block text-sm font-medium text-gray-500">Processing Status</label>
                            <p class="mt-1 text-sm text-gray-900">{{ video.status.title() }}</p>
                        </div>
                        
                        <div>
                            <label class="block text-sm font-medium text-gray-500">Priority</label>
                            <p class="mt-1 text-sm text-gray-900">{{ video.priority.title() if video.priority else 'Normal' }}</p>
                        </div>
                        
                        <div>
                            <label class="block text-sm font-medium text-gray-500">Started</label>
                            <p class="mt-1 text-sm text-gray-900">
                                {% if video.processing_started_at %}
                                    {{ video.processing_started_at.strftime('%b %d, %Y at %H:%M') }}
                                {% else %}
                                    Not started
                                {% endif %}
                            </p>
                        </div>
                        
                        <div>
                            <label class="block text-sm font-medium text-gray-500">Completed</label>
                            <p class="mt-1 text-sm text-gray-900">
                                {% if video.processing_completed_at %}
                                    {{ video.processing_completed_at.strftime('%b %d, %Y at %H:%M') }}
                                {% else %}
                                    Not completed
                                {% endif %}
                            </p>
                        </div>
                    </div>
                    
                    {% if video.status == 'failed' and video.error_message %}
                        <div class="bg-red-50 border border-red-200 rounded-md p-4">
                            <h4 class="text-sm font-medium text-red-800">Error Details</h4>
                            <p class="mt-1 text-sm text-red-700">{{ video.error_message }}</p>
                        </div>
                    {% endif %}
                    
                    <!-- Video Controls and Info -->
                    <div class="mt-4 text-sm text-gray-600">
                        <div class="flex justify-between items-center">
                            <div>
                                <span id="currentTimeDisplay">0:00</span> / <span id="durationDisplay">0:00</span>
                            </div>
                            <div id="detectionCounter" class="text-blue-600 font-medium">
                                No detection at current frame
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Detection Navigation Panel -->
            <div class="xl:w-1/3">
                <div class="bg-white rounded-lg shadow-md">
                    <!-- Header with Stats -->
                    <div class="p-4 border-b border-gray-200">
                        <div class="flex justify-between items-center mb-2">
                            <h2 class="text-lg font-semibold text-gray-800">Detection Navigator</h2>
                            <div class="flex space-x-1">
                                <button onclick="toggleDemoDebugMode()" 
                                        class="text-xs px-2 py-1 bg-yellow-100 text-yellow-700 rounded hover:bg-yellow-200"
                                        title="Demo debug mode (Press D key)">
                                    üéØ Demo
                                </button>
                                <button onclick="calibrateBoundingBoxes()" 
                                        class="text-xs px-2 py-1 bg-purple-100 text-purple-700 rounded hover:bg-purple-200"
                                        title="AI calibrate all detections (Press C key)">
                                    ü§ñ AI
                                </button>
                            </div>
                        </div>
                        <div class="flex justify-between text-sm text-gray-600">
                            <span>{{ total_detections }} persons detected</span>
                            <span>{{ identified_count }} identified</span>
                        </div>
                        {% if pagination and pagination.pages > 1 %}
                        <div class="mt-2 text-xs text-gray-500">
                            Page {{ current_page }} of {{ pagination.pages }} (showing {{ detections|length }} items)
                        </div>
                        {% endif %}
                    </div>
                    
                    <!-- Detection List (Scrollable) -->
                    {% if detections %}
                    <div class="max-h-96 overflow-y-auto">
                        {% for detection in detections %}
                        <div class="detection-item p-3 border-b border-gray-100 hover:bg-gray-50 cursor-pointer transition-colors"
                             data-detection-id="{{ detection.id }}"
                             data-timestamp="{{ detection.timestamp }}"
                             data-frame-number="{{ detection.frame_number }}"
                             data-bbox-x="{{ detection.bbox_x }}"
                             data-bbox-y="{{ detection.bbox_y }}"
                             data-bbox-width="{{ detection.bbox_width }}"
                             data-bbox-height="{{ detection.bbox_height }}"
                             onclick="navigateToDetection({{ detection.timestamp }}, {{ detection.id }}, {{ detection.bbox_x }}, {{ detection.bbox_y }}, {{ detection.bbox_width }}, {{ detection.bbox_height }})">
                            
                            <div class="flex justify-between items-start">
                                <div class="flex-1">
                                    <div class="font-medium text-gray-900">PERSON-{{ "%04d"|format(loop.index) }}</div>
                                    <div class="text-sm text-gray-600">{{ "%.2f"|format(detection.timestamp) }}s</div>
                                    <div class="text-xs text-gray-500">
                                        Confidence: {{ "%.1f"|format(detection.confidence * 100) }}%
                                    </div>
                                    <div class="text-xs text-gray-400">
                                        Box: {{ detection.bbox_x }},{{ detection.bbox_y }} {{ detection.bbox_width }}√ó{{ detection.bbox_height }}
                                    </div>
                                    {% if detection.is_identified %}
                                    <div class="text-xs text-green-600 font-medium">‚úÖ Identified</div>
                                    {% endif %}
                                </div>
                                <div class="ml-2 flex flex-col space-y-1">
                                    <button class="text-blue-600 hover:text-blue-800 text-sm font-medium"
                                            onclick="event.stopPropagation(); navigateToDetection({{ detection.timestamp }}, {{ detection.id }}, {{ detection.bbox_x }}, {{ detection.bbox_y }}, {{ detection.bbox_width }}, {{ detection.bbox_height }})">
                                        üéØ Go
                                    </button>
                                    <button class="text-purple-600 hover:text-purple-800 text-xs font-medium"
                                            onclick="event.stopPropagation(); calibrateBoundingBoxes({{ detection.id }})"
                                            title="AI calibrate this detection">
                                        ü§ñ Cal
                                    </button>
                                </div>
                            </div>
                        </div>
                        {% endfor %}
                    </div>
                    {% else %}
                    <div class="p-6 text-center text-gray-500">
                        No persons detected yet.
                        {% if video.status in ['uploaded', 'completed', 'failed'] %}
                        Start person extraction to see detections here.
                        {% endif %}
                    </div>
                    {% endif %}
                    
                    <!-- Pagination Controls -->
                    {% if pagination and pagination.pages > 1 %}
                    <div class="p-4 border-t border-gray-200 bg-gray-50">
                        <div class="flex justify-between items-center">
                            <!-- Previous Button -->
                            {% if pagination.has_prev %}
                            <a href="{{ url_for('videos.detail', id=video.id, page=pagination.prev_num) }}" 
                               class="inline-flex items-center px-3 py-1 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50">
                                <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
                                </svg>
                                Previous
                            </a>
                            {% else %}
                            <span class="inline-flex items-center px-3 py-1 text-sm font-medium text-gray-400 bg-gray-100 border border-gray-200 rounded-md cursor-not-allowed">
                                <svg class="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
                                </svg>
                                Previous
                            </span>
                            {% endif %}
                            
                            <!-- Page Info -->
                            <span class="text-sm text-gray-700">
                                Page <span class="font-medium">{{ current_page }}</span> of <span class="font-medium">{{ pagination.pages }}</span>
                            </span>
                            
                            <!-- Next Button -->
                            {% if pagination.has_next %}
                            <a href="{{ url_for('videos.detail', id=video.id, page=pagination.next_num) }}" 
                               class="inline-flex items-center px-3 py-1 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50">
                                Next
                                <svg class="w-4 h-4 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                                </svg>
                            </a>
                            {% else %}
                            <span class="inline-flex items-center px-3 py-1 text-sm font-medium text-gray-400 bg-gray-100 border border-gray-200 rounded-md cursor-not-allowed">
                                Next
                                <svg class="w-4 h-4 ml-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                                </svg>
                            </span>
                            {% endif %}
                        </div>
                        
                        <!-- Load More Button (Alternative) -->
                        <div class="mt-3 text-center">
                            <button onclick="loadMoreDetections()" 
                                    class="text-sm text-blue-600 hover:text-blue-800 font-medium"
                                    id="loadMoreBtn"
                                    data-page="{{ current_page }}"
                                    data-total-pages="{{ pagination.pages }}">
                                Load all detections (AJAX)
                            </button>
                        </div>
                    </div>
                    {% endif %}
                </div>
                
                <!-- Processing Controls -->
                <div class="mt-6 space-y-4">
                <!-- Enhanced Detection Results -->
                {% if video.annotated_video_path %}
                <div class="bg-blue-50 border border-blue-200 rounded-lg shadow-md p-6 mb-6">
                    <h2 class="text-lg font-semibold text-blue-800 mb-4">üéØ Enhanced Detection Results</h2>
                    
                    <div class="space-y-3">
                        <div class="flex justify-between">
                            <span class="text-sm text-blue-600">Total Detections</span>
                            <span class="text-sm font-medium text-blue-900">{{ detections|length }}</span>
                        </div>
                        
                        <div class="flex justify-between">
                            <span class="text-sm text-blue-600">Unique Persons</span>
                            <span class="text-sm font-medium text-blue-900">
                                {{ detections|groupby('person_id')|list|length if detections else 0 }}
                            </span>
                        </div>
                        
                        <div class="flex justify-between">
                            <span class="text-sm text-blue-600">Tracking Accuracy</span>
                            <span class="text-sm font-medium text-blue-900">
                                {% if detections %}
                                    {{ "%.1f"|format((detections|sum(attribute='confidence')/detections|length)*100) }}%
                                {% else %}
                                    --
                                {% endif %}
                            </span>
                        </div>
                        
                        {% if detections|groupby('person_id')|list|length > 0 %}
                        <div class="mt-4 pt-3 border-t border-blue-200">
                            <span class="text-sm font-medium text-blue-800">Person Tracks:</span>
                            <div class="mt-2 flex flex-wrap gap-2">
                                {% for person_id, person_detections in detections|groupby('person_id') %}
                                    {% if person_id %}
                                    <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-blue-100 text-blue-800">
                                        {{ person_id }} ({{ person_detections|list|length }} frames)
                                    </span>
                                    {% endif %}
                                {% endfor %}
                            </div>
                        </div>
                        {% endif %}
                    </div>
                </div>
                {% endif %}
                
                <!-- Quick Stats -->
                <div class="bg-white rounded-lg shadow-md p-6">
                    <h2 class="text-lg font-semibold text-gray-800 mb-4">Detection Results</h2>
                    
                    <div class="space-y-3">
                        <div class="flex justify-between">
                            <span class="text-sm text-gray-600">Persons Detected</span>
                            <span class="text-sm font-medium text-gray-900">{{ detections|length }}</span>
                        </div>
                        
                        <div class="flex justify-between">
                            <span class="text-sm text-gray-600">Identified</span>
                            <span class="text-sm font-medium text-gray-900">
                                {{ detections|selectattr('is_identified')|list|length }}
                            </span>
                        </div>
                        
                        <div class="flex justify-between">
                            <span class="text-sm text-gray-600">Confidence Score</span>
                            <span class="text-sm font-medium text-gray-900">
                                {% if detections %}
                                    {{ "%.1f"|format((detections|sum(attribute='confidence')/detections|length)*100) }}%
                                {% else %}
                                    --
                                {% endif %}
                            </span>
                        </div>
                    </div>
                </div>

                <!-- Actions -->
                <div class="bg-white rounded-lg shadow-md p-6">
                    <h2 class="text-lg font-semibold text-gray-800 mb-4">Actions</h2>
                    
                    <div class="space-y-3">
                        {% if video.status == 'uploaded' or (video.status == 'completed' and video.processed_path) %}
                            <!-- Status message for web-compatible videos -->
                            <div class="bg-green-50 border border-green-200 rounded-md p-4 mb-3">
                                {% if video.processed_path %}
                                    <h4 class="text-sm font-medium text-green-800 mb-2">‚úÖ Converted Video Ready</h4>
                                    <p class="text-sm text-green-700 mb-3">This video has been automatically converted to web-compatible MP4 format and is ready for processing.</p>
                                {% else %}
                                    <h4 class="text-sm font-medium text-green-800 mb-2">‚úÖ Web-Compatible Format</h4>
                                    <p class="text-sm text-green-700 mb-3">This video is already in a web-compatible format and ready to play.</p>
                                {% endif %}
                            </div>
                            
                            <!-- Process Video Form -->
                            <form action="{{ url_for('videos.process_video', id=video.id) }}" method="POST" class="space-y-3">
                                <div class="bg-blue-50 border border-blue-200 rounded-md p-4">
                                    <h4 class="text-sm font-medium text-blue-800 mb-3">Process Video Options</h4>
                                    
                                    {% if video.detected_persons and video.detected_persons|length > 0 %}
                                    <div class="bg-amber-50 border border-amber-200 rounded p-2 mb-3">
                                        <p class="text-xs text-amber-700">
                                            ‚ö†Ô∏è <strong>Note:</strong> This video has {{ video.detected_persons|length }} existing detection(s). 
                                            Processing will <strong>clear all existing data</strong> and re-extract persons from scratch.
                                        </p>
                                    </div>
                                    {% endif %}
                                    
                                    <div class="space-y-2">
                                        <label class="flex items-center">
                                            <input type="checkbox" name="extract_persons" value="true" checked class="rounded border-gray-300 text-blue-600 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50">
                                            <span class="ml-2 text-sm text-gray-700">Extract persons from video</span>
                                        </label>
                                        
                                        <label class="flex items-center">
                                            <input type="checkbox" name="face_recognition" value="true" class="rounded border-gray-300 text-blue-600 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50">
                                            <span class="ml-2 text-sm text-gray-700">Run face recognition</span>
                                        </label>
                                        
                                        <label class="flex items-center">
                                            <input type="checkbox" name="extract_frames" value="true" class="rounded border-gray-300 text-blue-600 shadow-sm focus:border-blue-300 focus:ring focus:ring-blue-200 focus:ring-opacity-50">
                                            <span class="ml-2 text-sm text-gray-700">Extract key frames</span>
                                        </label>
                                    </div>
                                </div>
                                
                                <button type="submit" class="w-full px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700" onclick="return confirm('Start person extraction for this video?{% if video.detected_persons and video.detected_persons|length > 0 %} This will delete {{ video.detected_persons|length }} existing detection(s) and start fresh.{% endif %}')">
                                    Process Video
                                </button>
                            </form>
                        {% elif video.status == 'converting' %}
                            <div class="bg-blue-50 border border-blue-200 rounded-md p-4">
                                <h4 class="text-sm font-medium text-blue-800 mb-2">üîÑ Auto-Converting Video</h4>
                                <div class="flex items-center mb-3">
                                    <div class="animate-spin rounded-full h-5 w-5 border-b-2 border-blue-600 mr-2"></div>
                                    <span class="text-sm text-blue-700">Automatically converting to web-compatible MP4 format...</span>
                                </div>
                                
                                <!-- Progress Bar -->
                                <div class="mb-3">
                                    <div class="flex justify-between text-xs text-blue-600 mb-1">
                                        <span>Progress</span>
                                        <span id="progressPercent">0%</span>
                                    </div>
                                    <div class="w-full bg-blue-200 rounded-full h-2 overflow-hidden">
                                        <div id="progressBar" class="bg-blue-600 h-2 rounded-full transition-all duration-300 progress-bar-animated" style="width: 0%"></div>
                                    </div>
                                </div>
                                
                                <!-- Progress Message -->
                                <div class="text-xs text-blue-600 mb-3">
                                    <div id="progressMessage">This video was detected as non-web-compatible and is being converted automatically...</div>
                                    <div class="mt-1">
                                        Started: {{ video.processing_started_at.strftime('%H:%M:%S') if video.processing_started_at }}
                                    </div>
                                </div>
                                
                                <!-- Real-time Status -->
                                <div id="conversionProgress" class="text-xs text-blue-600 bg-blue-100 p-2 rounded">
                                    <div class="flex items-center">
                                        <div class="h-2 w-2 bg-blue-600 rounded-full mr-2 live-indicator"></div>
                                        <span id="liveStatus" class="conversion-status-live">Checking conversion status...</span>
                                    </div>
                                </div>
                                
                                <!-- Debug Panel (only visible in converting state) -->
                                <div id="debugPanel" class="mt-4 p-3 bg-gray-100 rounded text-xs text-gray-600">
                                    <div class="font-medium mb-2">üîß Debug Information:</div>
                                    <div id="debugInfo">
                                        <div>‚Ä¢ Status: <span id="debugStatus">Unknown</span></div>
                                        <div>‚Ä¢ Progress: <span id="debugProgress">0%</span></div>
                                        <div>‚Ä¢ Message: <span id="debugMessage">No message</span></div>
                                        <div>‚Ä¢ Last Update: <span id="debugLastUpdate">Never</span></div>
                                        <div>‚Ä¢ API Calls: <span id="debugApiCalls">0</span></div>
                                        <div>‚Ä¢ Task ID: <span id="debugTaskId">None</span></div>
                                        <div>‚Ä¢ WebSocket: <span id="debugWebSocket">Disconnected</span></div>
                                        <div>‚Ä¢ Connection: <span id="debugConnection">AJAX Polling</span></div>
                                    </div>
                                    <button onclick="toggleDebugPanel()" class="mt-2 text-xs bg-gray-300 px-2 py-1 rounded">Hide Debug</button>
                                </div>
                            </div>
                        {% elif video.status == 'processing' %}
                            <!-- Processing status with cancel option -->
                            <div class="bg-yellow-50 border border-yellow-200 rounded-md p-4 mb-3">
                                <h4 class="text-sm font-medium text-yellow-800 mb-2">‚è≥ Person Extraction In Progress</h4>
                                <p class="text-sm text-yellow-700 mb-3">
                                    The system is currently extracting persons from this video. 
                                    {% if video.processing_started_at %}
                                        Started: {{ video.processing_started_at.strftime('%b %d at %H:%M') }}
                                    {% endif %}
                                </p>
                                <p class="text-xs text-yellow-600">
                                    If the process appears stuck, you can cancel and retry.
                                </p>
                            </div>
                            
                            <!-- Cancel Processing -->
                            <form action="{{ url_for('videos.cancel_processing', id=video.id) }}" method="POST">
                                <button type="submit" class="w-full px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700" onclick="return confirm('Cancel person extraction? This will stop the current process and reset the video so you can retry.')">
                                    üõë Cancel Processing
                                </button>
                            </form>
                        {% elif video.status == 'completed' %}
                            <button class="w-full px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700">
                                Run Face Recognition
                            </button>
                            
                            <button class="w-full px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700">
                                Export Results
                            </button>
                        {% elif video.status == 'failed' %}
                            <!-- Error status message -->
                            <div class="bg-red-50 border border-red-200 rounded-md p-4 mb-3">
                                <h4 class="text-sm font-medium text-red-800 mb-2">‚ùå Person Extraction Failed</h4>
                                <p class="text-sm text-red-700 mb-3">
                                    {% if video.error_message %}
                                        Error: {{ video.error_message }}
                                    {% else %}
                                        The person extraction process failed. You can retry with the same or different options.
                                    {% endif %}
                                </p>
                                
                                {% if video.processing_completed_at %}
                                    <p class="text-xs text-red-600">
                                        Failed at: {{ video.processing_completed_at.strftime('%b %d, %Y at %H:%M') }}
                                    </p>
                                {% endif %}
                            </div>
                            
                            <!-- Retry Processing Form -->
                            <form action="{{ url_for('videos.process_video', id=video.id) }}" method="POST" class="space-y-3">
                                <div class="bg-yellow-50 border border-yellow-200 rounded-md p-4">
                                    <h4 class="text-sm font-medium text-yellow-800 mb-3">üîÑ Retry Person Extraction</h4>
                                    
                                    {% if video.detected_persons and video.detected_persons|length > 0 %}
                                    <div class="bg-red-50 border border-red-200 rounded p-2 mb-3">
                                        <p class="text-xs text-red-700">
                                            ‚ö†Ô∏è <strong>Warning:</strong> This video has {{ video.detected_persons|length }} existing detection(s). 
                                            Retry will <strong>delete all existing data</strong> and start fresh person extraction.
                                        </p>
                                    </div>
                                    {% endif %}
                                    
                                    <div class="space-y-2">
                                        <label class="flex items-center">
                                            <input type="checkbox" name="extract_persons" value="true" checked class="rounded border-gray-300 text-yellow-600 shadow-sm focus:border-yellow-300 focus:ring focus:ring-yellow-200 focus:ring-opacity-50">
                                            <span class="ml-2 text-sm text-gray-700">Extract persons from video</span>
                                        </label>
                                        
                                        <label class="flex items-center">
                                            <input type="checkbox" name="face_recognition" value="true" class="rounded border-gray-300 text-yellow-600 shadow-sm focus:border-yellow-300 focus:ring focus:ring-yellow-200 focus:ring-opacity-50">
                                            <span class="ml-2 text-sm text-gray-700">Run face recognition</span>
                                        </label>
                                        
                                        <label class="flex items-center">
                                            <input type="checkbox" name="extract_frames" value="true" class="rounded border-gray-300 text-yellow-600 shadow-sm focus:border-yellow-300 focus:ring focus:ring-yellow-200 focus:ring-opacity-50">
                                            <span class="ml-2 text-sm text-gray-700">Extract key frames</span>
                                        </label>
                                    </div>
                                </div>
                                
                                <button type="submit" class="w-full px-4 py-2 bg-yellow-600 text-white rounded-md hover:bg-yellow-700" onclick="return confirm('Retry person extraction for this video?{% if video.detected_persons and video.detected_persons|length > 0 %} This will permanently delete {{ video.detected_persons|length }} existing detection(s) and start fresh extraction.{% endif %}')">
                                    üîÑ Retry Person Extraction
                                </button>
                            </form>
                        {% endif %}
                        
                        <a href="{{ url_for('videos.download_video', filename=video.file_path) }}" 
                           class="block w-full px-4 py-2 border border-gray-300 rounded-md text-gray-700 hover:bg-gray-50 text-center">
                            Download Original
                        </a>
                        
                        <!-- Delete Button -->
                        <form action="{{ url_for('videos.delete', id=video.id) }}" method="POST" 
                              onsubmit="return confirm('Are you sure you want to delete this video? This action cannot be undone.')">
                            <button type="submit" class="w-full px-4 py-2 border border-red-300 rounded-md text-red-700 hover:bg-red-50">
                                Delete Video
                            </button>
                        </form>
                        
                        <!-- Force Reset Button for stuck videos -->
                        {% if video.status == 'processing' %}
                        <form action="{{ url_for('videos.force_reset', id=video.id) }}" method="POST" 
                              onsubmit="return confirm('Force reset this video? This will mark it as failed and allow you to delete or retry it.')">
                            <button type="submit" class="w-full px-4 py-2 border border-orange-300 rounded-md text-orange-700 hover:bg-orange-50">
                                üîß Force Reset (Stuck Video)
                            </button>
                        </form>
                        {% endif %}
                        
                        <!-- Temporary testing button (remove in production) -->
                        {% if video.status in ['uploaded', 'completed'] %}
                        <form action="{{ url_for('videos.simulate_error', id=video.id) }}" method="POST" class="mt-2">
                            <button type="submit" class="w-full px-4 py-2 border border-orange-300 rounded-md text-orange-700 hover:bg-orange-50 text-sm" onclick="return confirm('Simulate an error to test retry functionality?')">
                                üß™ Simulate Error (Testing)
                            </button>
                        </form>
                        {% endif %}
                    </div>
                </div>

                <!-- Processing Log -->
                {% if video.processing_log %}
                <div class="bg-white rounded-lg shadow-md p-6">
                    <h2 class="text-lg font-semibold text-gray-800 mb-4">Processing Log</h2>
                    
                    <div class="bg-gray-50 rounded-md p-3 max-h-32 overflow-y-auto">
                        <pre class="text-xs text-gray-700 whitespace-pre-wrap">{{ video.processing_log }}</pre>
                    </div>
                </div>
                {% endif %}
            </div>
        </div>
    </div>

    <!-- Detailed Detected Persons Table (Bottom Section) -->
    {% if detections and detections|length > 0 %}
    <div class="container mx-auto px-4 mt-8">
        <div class="max-w-6xl mx-auto">
            <div class="bg-white rounded-lg shadow-md p-6">
                <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between mb-6">
                    <h2 class="text-xl font-semibold text-gray-800 mb-2 sm:mb-0">
                        Detailed Detection Results
                    </h2>
                    <div class="text-sm text-gray-600 bg-gray-50 px-3 py-2 rounded-md">
                        {{ detections|length }} person{{ 's' if detections|length != 1 }} detected ‚Ä¢ 
                        {{ detections|selectattr('is_identified')|list|length }} identified
                    </div>
                </div>
                
                <div class="overflow-x-auto">
                    <table class="min-w-full divide-y divide-gray-200">
                        <thead class="bg-gray-50">
                            <tr>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Person ID</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Timestamp</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Confidence</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Identity</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Location</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Actions</th>
                            </tr>
                        </thead>
                        <tbody class="bg-white divide-y divide-gray-200">
                            {% for detection in detections %}
                            <tr class="hover:bg-gray-50 detection-table-row" data-detection-id="{{ detection.id }}">
                                <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                                    PERSON-{{ "%04d"|format(loop.index) }}
                                </td>
                                <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                                    {{ "%.2f"|format(detection.timestamp) }}s
                                </td>
                                <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                                    <div class="flex items-center">
                                        <div class="w-16 bg-gray-200 rounded-full h-2 mr-2">
                                            <div class="bg-blue-600 h-2 rounded-full" style="width: {{ detection.confidence * 100 }}%"></div>
                                        </div>
                                        <span>{{ "%.1f"|format(detection.confidence * 100) }}%</span>
                                    </div>
                                </td>
                                <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                                    {% if detection.is_identified and detection.employee %}
                                        <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-green-100 text-green-800">
                                            ‚úÖ {{ detection.employee.name }}
                                        </span>
                                    {% else %}
                                        <span class="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-gray-100 text-gray-800">
                                            ‚ùì Unknown
                                        </span>
                                    {% endif %}
                                </td>
                                <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                                    {% if detection.bbox_x is number and detection.bbox_y is number and detection.bbox_width is number and detection.bbox_height is number %}
                                        <div class="text-xs">
                                            <div>X: {{ detection.bbox_x }}, Y: {{ detection.bbox_y }}</div>
                                            <div>{{ detection.bbox_width }}√ó{{ detection.bbox_height }}px</div>
                                        </div>
                                    {% else %}
                                        <span class="text-red-500 text-xs">‚ùå Invalid bbox data</span>
                                    {% endif %}
                                </td>
                                <td class="px-6 py-4 whitespace-nowrap text-sm font-medium">
                                    <div class="flex space-x-2">
                                        {% if detection.bbox_x is number and detection.bbox_y is number and detection.bbox_width is number and detection.bbox_height is number and detection.timestamp is number %}
                                            <button onclick="navigateToDetection({{ detection.timestamp }}, {{ detection.id }}, {{ detection.bbox_x }}, {{ detection.bbox_y }}, {{ detection.bbox_width }}, {{ detection.bbox_height }})" 
                                                    class="inline-flex items-center px-3 py-1 border border-blue-300 text-sm leading-4 font-medium rounded-md text-blue-700 bg-blue-50 hover:bg-blue-100 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
                                                    data-detection-id="{{ detection.id }}"
                                                    data-timestamp="{{ detection.timestamp }}"
                                                    data-frame-number="{{ detection.frame_number }}"
                                                    data-bbox-x="{{ detection.bbox_x }}"
                                                    data-bbox-y="{{ detection.bbox_y }}" 
                                                    data-bbox-width="{{ detection.bbox_width }}"
                                                    data-bbox-height="{{ detection.bbox_height }}">
                                                üéØ Go to Frame
                                            </button>
                                        {% else %}
                                            <span class="text-red-500 text-xs">‚ùå Invalid data</span>
                                        {% endif %}
                                        
                                        {% if not detection.is_identified %}
                                            <button onclick="identifyPerson({{ detection.id }})" 
                                                    class="inline-flex items-center px-3 py-1 border border-green-300 text-sm leading-4 font-medium rounded-md text-green-700 bg-green-50 hover:bg-green-100 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500">
                                                üë§ Identify
                                            </button>
                                        {% endif %}
                                    </div>
                                </td>
                            </tr>
                            {% endfor %}
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>
    {% endif %}
</div>

<script>
// Video handler functions are now defined at the top of the page

function tryAlternativePlayback() {
    const video = document.getElementById('videoPlayer');
    const error = document.getElementById('videoError');
    
    if (video) {
        // Try different serving method
        const filename = '{{ video.file_path }}';
        video.innerHTML = `
            <source src="{{ url_for('videos.serve_video_static', filename='') }}${filename}" type="application/octet-stream">
            <source src="{{ url_for('videos.download_video', filename='') }}${filename}" type="application/octet-stream">
        `;
        video.style.display = 'block';
        video.load();
        
        if (error) {
            error.classList.add('hidden');
        }
        
        // Show loading state
        const loading = document.getElementById('videoLoading');
        if (loading) {
            loading.classList.remove('hidden');
        }
        
        // Set timeout to show error again if still failing
        setTimeout(() => {
            if (video.readyState === 0) {
                handleVideoError();
                if (loading) loading.classList.add('hidden');
            }
        }, 5000);
    }
}

function showConversionInstructions() {
    document.getElementById('conversionInstructions').classList.remove('hidden');
}

function hideConversionInstructions() {
    document.getElementById('conversionInstructions').classList.add('hidden');
}

function openDiagnosticTool() {
    window.open('/static/video_test.html', '_blank');
}

function checkConversionStatus() {
    const videoId = {{ video.id }};
    
    console.log(`üîç Checking conversion status for video ${videoId}...`);
    
    fetch(`/videos/api/${videoId}/conversion-status`)
        .then(response => {
            console.log(`üì° API Response status: ${response.status}`);
            return response.json();
        })
        .then(data => {
            console.log('üìä Conversion status data received:', data);
            console.log('üìä Data details:', {
                status: data.status,
                progress: data.progress,
                message: data.progress_message,
                taskId: data.task_id,
                timestamp: new Date().toLocaleTimeString()
            });
            updateProgressUI(data);
        })
        .catch(error => {
            console.error('‚ùå Error checking conversion status:', error);
            const liveStatus = document.getElementById('liveStatus');
            if (liveStatus) {
                liveStatus.textContent = '‚ö†Ô∏è Error checking status. Please refresh the page.';
            }
        });
}

function updateProgressUI(data) {
    console.log('üé® Updating progress UI with data:', data);
    
    const progressBar = document.getElementById('progressBar');
    const progressPercent = document.getElementById('progressPercent');
    const progressMessage = document.getElementById('progressMessage');
    const liveStatus = document.getElementById('liveStatus');
    
    // Update debug information
    updateDebugInfo(data);
    
    // Log current UI elements
    console.log('üìã UI Elements found:', {
        progressBar: !!progressBar,
        progressPercent: !!progressPercent, 
        progressMessage: !!progressMessage,
        liveStatus: !!liveStatus
    });
    
    if (data.status === 'completed') {
        console.log('‚úÖ Conversion completed!');
        if (progressBar) progressBar.style.width = '100%';
        if (progressPercent) progressPercent.textContent = '100%';
        if (progressMessage) progressMessage.textContent = 'Conversion completed successfully!';
        if (liveStatus) liveStatus.innerHTML = '‚úÖ Conversion completed! Reloading page...';
        
        // Clear the progress interval and disconnect WebSocket
        if (window.conversionProgressInterval) {
            clearInterval(window.conversionProgressInterval);
            window.conversionProgressInterval = null;
        }
        
        if (socket) {
            socket.emit('leave_video_room', { video_id: {{ video.id }} });
        }
        
        setTimeout(() => location.reload(), 2000);
        
    } else if (data.status === 'failed') {
        console.log('‚ùå Conversion failed:', data.error_message);
        if (progressBar) progressBar.style.width = '0%';
        if (progressPercent) progressPercent.textContent = '0%';
        if (progressMessage) progressMessage.textContent = 'Conversion failed';
        if (liveStatus) liveStatus.innerHTML = `‚ùå Conversion failed: ${data.error_message || 'Unknown error'}`;
        
        // Clear the progress interval and disconnect WebSocket
        if (window.conversionProgressInterval) {
            clearInterval(window.conversionProgressInterval);
            window.conversionProgressInterval = null;
        }
        
        if (socket) {
            socket.emit('leave_video_room', { video_id: {{ video.id }} });
        }
        
    } else if (data.status === 'converting') {
        const progress = data.progress || 0;
        const message = data.progress_message || 'Converting...';
        
        console.log(`üîÑ Converting: ${progress.toFixed(1)}% - ${message}`);
        
        // Update progress bar with animation
        if (progressBar) {
            progressBar.style.width = `${progress}%`;
            progressBar.style.transition = 'width 0.3s ease-in-out';
        }
        if (progressPercent) progressPercent.textContent = `${progress.toFixed(1)}%`;
        
        // Update messages
        if (progressMessage) progressMessage.textContent = message;
        
        // Calculate elapsed time
        const elapsed = data.processing_started_at ? 
            Math.round((new Date() - new Date(data.processing_started_at)) / 1000) : 0;
        
        const elapsedMinutes = Math.floor(elapsed / 60);
        const elapsedSeconds = elapsed % 60;
        const elapsedText = elapsedMinutes > 0 ? 
            `${elapsedMinutes}m ${elapsedSeconds}s` : `${elapsedSeconds}s`;
        
        if (liveStatus) {
            liveStatus.innerHTML = `üîÑ ${message} (${elapsedText} elapsed)`;
        }
        
        // Update page title to show progress
        document.title = `Converting ${progress.toFixed(1)}% - ${message}`;
        
        // Visual feedback: pulse effect on high progress
        if (progress > 80 && progressBar) {
            progressBar.style.animation = 'pulse 1s infinite';
        } else if (progressBar) {
            progressBar.style.animation = 'none';
        }
        
    } else {
        console.log('‚ö†Ô∏è Unknown status:', data.status);
        if (liveStatus) {
            liveStatus.textContent = `Status: ${data.status}`;
        }
    }
}

// WebSocket connection for real-time progress updates
let socket = null;

function initializeWebSocket() {
    const videoId = {{ video.id }};
    const videoStatus = '{{ video.status }}';
    
    console.log('üì° Initializing WebSocket connection...');
    
    // Initialize Socket.IO connection
    socket = io();
    
    socket.on('connect', function() {
        console.log('üì° WebSocket connected');
        
        // Join the video-specific room for updates
        socket.emit('join_video_room', { video_id: videoId });
        
        // Request current status
        socket.emit('request_video_status', { video_id: videoId });
    });
    
    socket.on('disconnect', function() {
        console.log('üì° WebSocket disconnected');
    });
    
    socket.on('status', function(data) {
        console.log('üì° WebSocket status:', data.message);
    });
    
    socket.on('conversion_progress', function(data) {
        console.log('üîÑ WebSocket progress update:', data);
        
        // Only process updates for this video
        if (data.video_id === videoId) {
            updateProgressUI(data);
        }
    });
    
    socket.on('video_status', function(data) {
        console.log('üìä WebSocket video status:', data);
        
        // Process current status response
        if (data.video_id === videoId) {
            updateProgressUI(data);
        }
    });
    
    // Handle connection errors
    socket.on('connect_error', function(error) {
        console.error('üì° WebSocket connection error:', error);
        console.log('üì° Falling back to AJAX polling...');
        
        // Fallback to AJAX polling if WebSocket fails
        if (videoStatus === 'converting') {
            setupAjaxPolling();
        }
    });
}

function setupAjaxPolling() {
    console.log('üîÑ Setting up AJAX polling fallback...');
    
    // Initial check immediately
    checkConversionStatus();
    
    // Check status every 3 seconds for frequent updates
    const progressInterval = setInterval(function() {
        checkConversionStatus();
    }, 3000);
    
    // Store interval ID so we can clear it if needed
    window.conversionProgressInterval = progressInterval;
    
    // Clear interval when page is hidden/unloaded
    document.addEventListener('visibilitychange', function() {
        if (document.hidden && window.conversionProgressInterval) {
            clearInterval(window.conversionProgressInterval);
            console.log('‚è∏Ô∏è Paused progress tracking (page hidden)');
        } else if (!document.hidden && '{{ video.status }}' === 'converting') {
            // Resume when page becomes visible again
            window.conversionProgressInterval = setInterval(checkConversionStatus, 3000);
            console.log('‚ñ∂Ô∏è Resumed progress tracking (page visible)');
        }
    });
}

// Initialize real-time updates
document.addEventListener('DOMContentLoaded', function() {
    const videoStatus = '{{ video.status }}';
    
    if (videoStatus === 'converting') {
        console.log('üîÑ Video is converting, setting up real-time progress tracking...');
        
        // Try WebSocket first, fallback to AJAX polling
        if (typeof io !== 'undefined') {
            initializeWebSocket();
        } else {
            console.log('üì° Socket.IO not available, using AJAX polling...');
            setupAjaxPolling();
        }
    } else if (videoStatus === 'processing') {
        console.log('üîÑ Video is processing (person extraction), setting up progress tracking...');
        setupProcessingPolling();
    }
});

function setupProcessingPolling() {
    console.log('üîÑ Setting up person extraction progress polling...');
    
    // Track polling state
    window.processingPollCount = 0;
    window.processingStartTime = Date.now();
    window.lastProgressUpdate = Date.now();
    window.maxPollAttempts = 300; // 10 minutes at 2-second intervals
    window.stuckTimeout = 60000; // 60 seconds without progress = stuck
    
    // Initial check immediately
    checkProcessingStatus();
    
    // Check status every 2 seconds for frequent updates
    const processingInterval = setInterval(function() {
        checkProcessingStatus();
    }, 2000);
    
    // Store interval ID so we can clear it if needed
    window.processingProgressInterval = processingInterval;
    
    // Clear interval when page is hidden/unloaded
    document.addEventListener('visibilitychange', function() {
        if (document.hidden && window.processingProgressInterval) {
            clearInterval(window.processingProgressInterval);
            console.log('‚è∏Ô∏è Paused person extraction tracking (page hidden)');
        } else if (!document.hidden && '{{ video.status }}' === 'processing') {
            // Resume when page becomes visible again
            window.processingProgressInterval = setInterval(checkProcessingStatus, 2000);
            console.log('‚ñ∂Ô∏è Resumed person extraction tracking (page visible)');
        }
    });
}

function checkProcessingStatus() {
    const videoId = {{ video.id }};
    
    window.processingPollCount++;
    const elapsedTime = Date.now() - window.processingStartTime;
    const timeSinceLastUpdate = Date.now() - window.lastProgressUpdate;
    
    console.log(`üîç Checking person extraction status for video ${videoId} (attempt ${window.processingPollCount}, elapsed: ${Math.round(elapsedTime/1000)}s)`);
    
    // Check for timeout scenarios
    if (window.processingPollCount > window.maxPollAttempts) {
        console.error('‚è∞ Processing timeout: exceeded maximum poll attempts');
        showProcessingError('Processing timed out after 10 minutes', true);
        return;
    }
    
    if (timeSinceLastUpdate > window.stuckTimeout) {
        console.error('‚è∞ Processing appears stuck: no progress for over 60 seconds');
        showProcessingError('Processing appears stuck. No progress detected for over 1 minute.', true);
        return;
    }
    
    fetch(`/videos/api/${videoId}/processing-status`)
        .then(response => {
            console.log(`üì° Processing API Response status: ${response.status}`);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            return response.json();
        })
        .then(data => {
            console.log('üìä Person extraction status data received:', data);
            console.log('   üîß Data details:', JSON.stringify(data, null, 2));
            updateProcessingUI(data);
        })
        .catch(error => {
            console.error('‚ùå Error checking person extraction status:', error);
            
            // After 3 consecutive failures, show error UI
            window.consecutiveFailures = (window.consecutiveFailures || 0) + 1;
            
            if (window.consecutiveFailures >= 3) {
                showProcessingError('Network error: Unable to check processing status', true);
            } else {
                const message = document.getElementById('processingMessage');
                if (message) {
                    message.textContent = `‚ö†Ô∏è Connection error (${window.consecutiveFailures}/3). Retrying...`;
                }
            }
        });
}

function updateProcessingUI(data) {
    console.log('üé® Updating person extraction UI with data:', data);
    
    const progressBar = document.getElementById('processingProgressBar');
    const progressPercent = document.getElementById('processingPercent');
    const progressMessage = document.getElementById('processingMessage');
    
    // Reset consecutive failures on successful response
    window.consecutiveFailures = 0;
    
    // Log current UI elements
    console.log('üìã Processing UI Elements found:', {
        progressBar: !!progressBar,
        progressPercent: !!progressPercent, 
        progressMessage: !!progressMessage
    });
    
    if (data.status === 'completed') {
        console.log('‚úÖ Person extraction completed!');
        if (progressBar) progressBar.style.width = '100%';
        if (progressPercent) progressPercent.textContent = '100%';
        if (progressMessage) progressMessage.textContent = 'Person extraction completed successfully!';
        
        // Clear the progress interval
        if (window.processingProgressInterval) {
            clearInterval(window.processingProgressInterval);
            window.processingProgressInterval = null;
        }
        
        setTimeout(() => location.reload(), 2000);
        
    } else if (data.status === 'failed') {
        console.log('‚ùå Person extraction failed:', data.error_message);
        showProcessingError(data.error_message || 'Unknown error', true);
        
    } else if (data.status === 'processing') {
        const progress = data.progress || 0;
        const message = data.progress_message || 'Processing...';
        
        console.log(`üîÑ Person extraction: ${progress.toFixed(1)}% - ${message}`);
        
        // Track progress updates for stuck detection
        const currentProgress = Math.floor(progress);
        if (currentProgress > (window.lastProgress || 0)) {
            window.lastProgress = currentProgress;
            window.lastProgressUpdate = Date.now();
        }
        
        // Update progress bar with animation
        if (progressBar) {
            progressBar.style.width = `${progress}%`;
            progressBar.style.transition = 'width 0.3s ease-in-out';
            
            // Add visual feedback when progress updates
            if (progress > (window.lastVisualProgress || 0)) {
                progressBar.style.backgroundColor = '#22c55e'; // Green flash
                setTimeout(() => {
                    progressBar.style.backgroundColor = '#2563eb'; // Back to blue
                }, 300);
                window.lastVisualProgress = progress;
            }
            
            console.log(`   üìä Updated progress bar to ${progress}%`);
        } else {
            console.warn('   ‚ö†Ô∏è Progress bar element not found!');
        }
        
        if (progressPercent) {
            progressPercent.textContent = `${progress.toFixed(1)}%`;
            console.log(`   üî¢ Updated progress text to ${progress.toFixed(1)}%`);
        } else {
            console.warn('   ‚ö†Ô∏è Progress percent element not found!');
        }
        
        // Update messages
        if (progressMessage) {
            progressMessage.textContent = message;
            console.log(`   üí¨ Updated progress message to: ${message}`);
        } else {
            console.warn('   ‚ö†Ô∏è Progress message element not found!');
        }
        
        // Update page title to show progress
        document.title = `Processing ${progress.toFixed(1)}% - ${message}`;
        
    } else {
        console.log('‚ö†Ô∏è Unknown processing status:', data.status);
        if (progressMessage) {
            progressMessage.textContent = `Status: ${data.status}`;
        }
    }
}

function showProcessingError(errorMessage, showRetryButton = false) {
    console.error('üí• Showing processing error:', errorMessage);
    
    // Clear polling interval
    if (window.processingProgressInterval) {
        clearInterval(window.processingProgressInterval);
        window.processingProgressInterval = null;
    }
    
    const progressBar = document.getElementById('processingProgressBar');
    const progressPercent = document.getElementById('processingPercent');
    const progressMessage = document.getElementById('processingMessage');
    
    // Update UI to show error
    if (progressBar) {
        progressBar.style.width = '0%';
        progressBar.style.backgroundColor = '#dc2626'; // Red color
    }
    if (progressPercent) {
        progressPercent.textContent = 'Error';
        progressPercent.style.color = '#dc2626';
    }
    
    if (progressMessage) {
        progressMessage.innerHTML = showRetryButton ? 
            `‚ùå ${errorMessage}<br>
             <button onclick="cancelProcessing()" class="mt-2 px-3 py-1 bg-red-600 text-white text-xs rounded hover:bg-red-700">
                üõë Cancel & Reset
             </button>
             <button onclick="location.reload()" class="mt-2 ml-2 px-3 py-1 bg-gray-600 text-white text-xs rounded hover:bg-gray-700">
                ‚Üª Refresh Page
             </button>` :
            `‚ùå ${errorMessage}`;
        progressMessage.style.color = '#dc2626';
    }
    
    // Update page title
    document.title = 'Processing Failed - Person Extraction Error';
}

function cancelProcessing() {
    const videoId = {{ video.id }};
    
    console.log('üõë Cancelling processing for video:', videoId);
    
    // Show loading state
    const progressMessage = document.getElementById('processingMessage');
    if (progressMessage) {
        progressMessage.innerHTML = 'üõë Cancelling processing...';
        progressMessage.style.color = '#dc2626';
    }
    
    // Make POST request to cancel processing
    fetch(`/videos/${videoId}/cancel-processing`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
        }
    })
    .then(response => {
        if (response.ok) {
            console.log('‚úÖ Successfully cancelled processing');
            location.reload();
        } else {
            throw new Error(`HTTP ${response.status}`);
        }
    })
    .catch(error => {
        console.error('‚ùå Error cancelling processing:', error);
        if (progressMessage) {
            progressMessage.innerHTML = `‚ùå Failed to cancel processing: ${error.message}<br>
                <button onclick="cancelProcessing()" class="mt-2 px-3 py-1 bg-red-600 text-white text-xs rounded hover:bg-red-700">
                    üõë Try Again
                </button>`;
        }
    });
}

function retryProcessing() {
    const videoId = {{ video.id }};
    
    console.log('üîÑ Retrying person extraction for video:', videoId);
    
    // Show loading state
    const progressMessage = document.getElementById('processingMessage');
    if (progressMessage) {
        progressMessage.innerHTML = 'üîÑ Restarting person extraction...';
        progressMessage.style.color = '#2563eb';
    }
    
    // Make POST request to restart processing
    fetch(`/videos/${videoId}/process`, {
        method: 'POST',
        headers: {
            'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: 'extract_persons=true&face_recognition=false&extract_frames=false'
    })
    .then(response => {
        if (response.ok) {
            console.log('‚úÖ Successfully restarted person extraction');
            // Restart progress tracking
            setTimeout(() => {
                location.reload();
            }, 1000);
        } else {
            throw new Error(`HTTP ${response.status}`);
        }
    })
    .catch(error => {
        console.error('‚ùå Error restarting processing:', error);
        if (progressMessage) {
            progressMessage.innerHTML = `‚ùå Failed to restart processing: ${error.message}<br>
                <button onclick="retryProcessing()" class="mt-2 px-3 py-1 bg-blue-600 text-white text-xs rounded hover:bg-blue-700">
                    üîÑ Try Again
                </button>`;
        }
    });
}

// Add video event listeners
document.addEventListener('DOMContentLoaded', function() {
    const video = document.getElementById('videoPlayer');
    if (video) {
        video.addEventListener('loadstart', function() {
            console.log('Video load started');
            const loading = document.getElementById('videoLoading');
            if (loading) loading.classList.remove('hidden');
        });
        
        video.addEventListener('canplay', function() {
            console.log('Video can start playing');
            const loading = document.getElementById('videoLoading');
            if (loading) loading.classList.add('hidden');
        });
        
        video.addEventListener('loadedmetadata', function() {
            console.log('Video metadata loaded');
            updateTimeDisplay();
        });
        
        video.addEventListener('timeupdate', function() {
            updateTimeDisplay();
            updateDetectionCounter();
        });
        
        video.addEventListener('error', function(e) {
            console.log('Video error:', e);
            handleVideoError();
            const loading = document.getElementById('videoLoading');
            if (loading) loading.classList.add('hidden');
        });
        
        // Initialize time display
        setTimeout(() => {
            updateTimeDisplay();
        }, 100);
        
        video.addEventListener('stalled', function() {
            console.log('Video stalled');
            const loading = document.getElementById('videoLoading');
            if (loading) loading.classList.remove('hidden');
        });
        
        video.addEventListener('waiting', function() {
            console.log('Video waiting for data');
            const loading = document.getElementById('videoLoading');
            if (loading) loading.classList.remove('hidden');
        });
        
        video.addEventListener('playing', function() {
            console.log('Video is playing');
            const loading = document.getElementById('videoLoading');
            if (loading) loading.classList.add('hidden');
        });
    }
});

// Debug functionality
let debugApiCallCount = 0;

function updateDebugInfo(data) {
    debugApiCallCount++;
    const now = new Date().toLocaleTimeString();
    
    // Update debug panel elements
    const debugStatus = document.getElementById('debugStatus');
    const debugProgress = document.getElementById('debugProgress');
    const debugMessage = document.getElementById('debugMessage');
    const debugLastUpdate = document.getElementById('debugLastUpdate');
    const debugApiCalls = document.getElementById('debugApiCalls');
    const debugTaskId = document.getElementById('debugTaskId');
    
    if (debugStatus) debugStatus.textContent = data.status || 'Unknown';
    if (debugProgress) debugProgress.textContent = data.progress ? `${data.progress.toFixed(1)}%` : '0%';
    if (debugMessage) debugMessage.textContent = data.progress_message || 'No message';
    if (debugLastUpdate) debugLastUpdate.textContent = now;
    if (debugApiCalls) debugApiCalls.textContent = debugApiCallCount;
    if (debugTaskId) debugTaskId.textContent = data.task_id || 'None';
    
    // Update WebSocket status
    const debugWebSocket = document.getElementById('debugWebSocket');
    const debugConnection = document.getElementById('debugConnection');
    
    if (debugWebSocket && socket) {
        debugWebSocket.textContent = socket.connected ? 'Connected' : 'Disconnected';
        debugWebSocket.style.color = socket.connected ? 'green' : 'red';
    }
    
    if (debugConnection) {
        debugConnection.textContent = socket && socket.connected ? 'WebSocket' : 'AJAX Polling';
        debugConnection.style.color = socket && socket.connected ? 'green' : 'orange';
    }
    
    console.log('üîß Debug info updated:', {
        status: data.status,
        progress: data.progress,
        message: data.progress_message,
        apiCalls: debugApiCallCount,
        websocket: socket ? socket.connected : false,
        time: now
    });
}

function toggleDebugPanel() {
    const debugPanel = document.getElementById('debugPanel');
    if (debugPanel) {
        const isVisible = !debugPanel.classList.contains('hidden');
        if (isVisible) {
            debugPanel.classList.add('hidden');
        } else {
            debugPanel.classList.remove('hidden');
        }
        
        // Update button text
        const button = debugPanel.querySelector('button[onclick="toggleDebugPanel()"]');
        if (button) {
            button.textContent = isVisible ? 'Show Debug' : 'Hide Debug';
        }
        
        console.log(`üîß Debug panel ${isVisible ? 'hidden' : 'shown'}`);
    }
}

// Enhanced navigation for person detection
function navigateToDetection(timestamp, detectionId, bboxX, bboxY, bboxWidth, bboxHeight) {
    console.log(`üéØ Navigating to detection ${detectionId} at ${timestamp}s`);
    console.log(`üìä Parameters: timestamp=${timestamp}, detectionId=${detectionId}, bbox=[${bboxX}, ${bboxY}, ${bboxWidth}x${bboxHeight}]`);
    
    const video = document.getElementById('videoPlayer');
    if (!video) {
        console.error('‚ùå Video player not found');
        return;
    }
    
    // Validate parameters
    if (isNaN(timestamp) || timestamp < 0) {
        console.error('‚ùå Invalid timestamp:', timestamp);
        return;
    }
    
    if (isNaN(bboxX) || isNaN(bboxY) || isNaN(bboxWidth) || isNaN(bboxHeight)) {
        console.error('‚ùå Invalid bounding box coordinates:', { bboxX, bboxY, bboxWidth, bboxHeight });
        return;
    }
    
    // Wait for video metadata to be loaded
    if (video.readyState < 1) {
        console.log('‚è≥ Waiting for video metadata to load...');
        video.addEventListener('loadedmetadata', function() {
            performNavigation();
        }, { once: true });
    } else {
        performNavigation();
    }
    
    function performNavigation() {
        console.log(`üé¨ Video duration: ${video.duration}s, seeking to: ${timestamp}s`);
        
        // Validate timestamp against video duration
        if (timestamp > video.duration) {
            console.warn('‚ö†Ô∏è Timestamp exceeds video duration, adjusting...');
            timestamp = Math.min(timestamp, video.duration - 0.1);
        }
        
        // Seek to timestamp and PAUSE (don't auto-play)
        video.currentTime = timestamp;
        if (!video.paused) {
            video.pause();
        }
        
        // Highlight the detection row
        highlightDetectionInNavigator(detectionId);
        
        // Show bounding box with person label
        showEnhancedBoundingBox(bboxX, bboxY, bboxWidth, bboxHeight, timestamp, detectionId);
        
        // Update current time display
        updateTimeDisplay();
        
        console.log('‚úÖ Navigation to detection completed');
    }
}

// Legacy function for compatibility
function jumpToDetection(timestamp, detectionId, bboxX, bboxY, bboxWidth, bboxHeight) {
    console.log(`üéØ Jumping to detection ${detectionId} at ${timestamp}s`);
    console.log(`üìä Parameters: timestamp=${timestamp}, detectionId=${detectionId}, bbox=[${bboxX}, ${bboxY}, ${bboxWidth}x${bboxHeight}]`);
    
    const video = document.getElementById('videoPlayer');
    if (!video) {
        console.error('‚ùå Video player not found');
        alert('Video player not found!');
        return;
    }
    
    // Validate parameters
    if (isNaN(timestamp) || timestamp < 0) {
        console.error('‚ùå Invalid timestamp:', timestamp);
        alert('Invalid timestamp: ' + timestamp);
        return;
    }
    
    if (isNaN(bboxX) || isNaN(bboxY) || isNaN(bboxWidth) || isNaN(bboxHeight)) {
        console.error('‚ùå Invalid bounding box coordinates:', { bboxX, bboxY, bboxWidth, bboxHeight });
        alert('Invalid bounding box coordinates');
        return;
    }
    
    // Wait for video metadata to be loaded
    if (video.readyState < 1) {
        console.log('‚è≥ Waiting for video metadata to load...');
        video.addEventListener('loadedmetadata', function() {
            performJump();
        }, { once: true });
    } else {
        performJump();
    }
    
    function performJump() {
        console.log(`üé¨ Video duration: ${video.duration}s, seeking to: ${timestamp}s`);
        
        // Validate timestamp against video duration
        if (timestamp > video.duration) {
            console.warn('‚ö†Ô∏è Timestamp exceeds video duration, adjusting...');
            timestamp = Math.min(timestamp, video.duration - 0.1);
        }
        
        // Jump to the timestamp and PAUSE (as requested - no auto-play)
        video.currentTime = timestamp;
        if (!video.paused) {
            video.pause();
        }
        
        // Highlight the detection in the table
        highlightDetectionRow(detectionId);
        
        // Show bounding box overlay (if video container supports it)
        showBoundingBox(bboxX, bboxY, bboxWidth, bboxHeight, timestamp);
        
        // Scroll video into view
        video.scrollIntoView({ behavior: 'smooth', block: 'center' });
        
        console.log('‚úÖ Jump to detection completed');
    }
}

function navigateToDetection(timestamp, detectionId, bboxX, bboxY, bboxWidth, bboxHeight) {
    console.log(`üß≠ Enhanced navigation to detection: ${detectionId} at ${timestamp}s`);
    
    const video = document.getElementById('videoPlayer');
    if (!video) {
        console.error('‚ùå Video player not found');
        return;
    }
    
    // Get improved timestamp with frame-based correction
    const correctedTimestamp = improveFPSCorrection(timestamp, detectionId, video);
    
    console.log(`üìä Timestamp correction: Original=${timestamp}s, Corrected=${correctedTimestamp}s`);
    
    // Wait for video metadata if needed
    if (video.readyState < 1) {
        console.log('‚è≥ Waiting for video metadata...');
        video.addEventListener('loadedmetadata', function() {
            performNavigation(correctedTimestamp);
        }, { once: true });
    } else {
        performNavigation(correctedTimestamp);
    }
    
    function performNavigation(finalTimestamp) {
        console.log(`üé¨ Navigating to corrected timestamp: ${finalTimestamp}s`);
        
        // Validate final timestamp
        if (finalTimestamp > video.duration) {
            console.warn('‚ö†Ô∏è Corrected timestamp exceeds duration, adjusting...');
            finalTimestamp = Math.min(finalTimestamp, video.duration - 0.1);
        }
        
        // Navigate to timestamp and PAUSE (no auto-play as requested)
        video.currentTime = finalTimestamp;
        if (!video.paused) {
            video.pause();
        }
        
        // Highlight detection in navigator panel
        highlightDetectionInNavigator(detectionId);
        
        // Show enhanced bounding box with person label and 1-second blink
        showEnhancedBoundingBox(bboxX, bboxY, bboxWidth, bboxHeight, finalTimestamp, detectionId);
        
        // Update time display
        updateTimeDisplay(finalTimestamp);
        
        // Update detection counter
        updateDetectionCounter(detectionId, finalTimestamp);
        
        console.log('‚úÖ Enhanced navigation completed');
    }
}

function improveFPSCorrection(timestamp, detectionId, video) {
    try {
        // Get video duration and frame rate estimation
        const duration = video.duration || 0;
        
        // Check if we have frame number data from the detection row
        const detectionRow = document.querySelector(`[data-detection-id="${detectionId}"]`);
        if (detectionRow && detectionRow.dataset.frameNumber) {
            const frameNumber = parseInt(detectionRow.dataset.frameNumber);
            if (!isNaN(frameNumber) && frameNumber > 0) {
                const estimatedFPS = getVideoFrameRate(video);
                const frameBasedTimestamp = frameNumber / estimatedFPS;
                
                console.log(`üîß Frame-based correction: Frame ${frameNumber} / ${estimatedFPS}fps = ${frameBasedTimestamp}s (was ${timestamp}s)`);
                return frameBasedTimestamp;
            }
        }
        
        // Apply heuristic corrections for common FPS mismatches
        const correctionFactors = [1.0, 29.97/30, 25/30, 24/30, 30/25, 30/29.97];
        let bestTimestamp = timestamp;
        let minError = Infinity;
        
        // Try different FPS correction factors
        for (const factor of correctionFactors) {
            const candidateTimestamp = timestamp * factor;
            if (candidateTimestamp <= duration) {
                const error = Math.abs(candidateTimestamp - timestamp);
                if (error < minError && candidateTimestamp >= 0) {
                    minError = error;
                    bestTimestamp = candidateTimestamp;
                }
            }
        }
        
        // Apply small timing offset to account for encoding/processing differences
        const finalTimestamp = Math.max(0, bestTimestamp - 0.05); // 50ms offset
        
        console.log(`üîß FPS correction applied: ${timestamp}s -> ${finalTimestamp}s (factor used)`);
        return finalTimestamp;
        
    } catch (e) {
        console.warn('‚ö†Ô∏è FPS correction failed, using original timestamp:', e);
        return timestamp;
    }
}

function getVideoFrameRate(video) {
    try {
        // Try to get FPS from backend data if available
        const videoDataElement = document.querySelector('[data-video-fps]');
        if (videoDataElement && videoDataElement.dataset.videoFps) {
            const backendFPS = parseFloat(videoDataElement.dataset.videoFps);
            if (!isNaN(backendFPS) && backendFPS > 0) {
                console.log(`üìä Using backend-provided FPS: ${backendFPS}`);
                return backendFPS;
            }
        }
        
        // Try browser-specific frame rate detection
        if (video.mozFrameRate) {
            console.log(`üìä Using Firefox frame rate: ${video.mozFrameRate}`);
            return video.mozFrameRate;
        }
        if (video.webkitFrameRate) {
            console.log(`üìä Using WebKit frame rate: ${video.webkitFrameRate}`);
            return video.webkitFrameRate;
        }
        
        // Analyze video metadata for frame rate hints
        const duration = video.duration;
        if (duration > 0) {
            // Common frame rates based on duration patterns
            const commonFPS = [23.976, 24, 25, 29.97, 30, 50, 59.94, 60];
            
            // For now, use intelligent defaults based on video duration
            if (duration < 60) {
                // Short videos often use higher frame rates
                console.log('üìä Short video detected, assuming 30fps');
                return 30;
            } else {
                // Longer videos might use standard frame rates
                console.log('üìä Standard video detected, assuming 30fps');
                return 30;
            }
        }
        
        // Final fallback
        console.log('‚ö†Ô∏è Could not determine frame rate, using 30fps default');
        return 30;
    } catch (e) {
        console.log('‚ö†Ô∏è Frame rate detection failed, using 30fps default');
        return 30;
    }
}

function updateTimeDisplay(currentTime) {
    const currentTimeDisplay = document.getElementById('currentTimeDisplay');
    if (currentTimeDisplay) {
        currentTimeDisplay.textContent = formatTimestamp(currentTime);
    }
}

function updateDetectionCounter(detectionId, timestamp) {
    const counter = document.getElementById('detectionCounter');
    if (counter) {
        counter.textContent = `PERSON-${String(detectionId).padStart(4, '0')} at ${timestamp.toFixed(1)}s`;
        counter.className = 'text-blue-600 font-medium bg-blue-50 px-2 py-1 rounded';
    }
}

function convertBoundingBoxCoordinates(bboxX, bboxY, bboxWidth, bboxHeight, video, displayWidth, displayHeight) {
    console.log(`üéØ CRITICAL BBOX CONVERSION for DEMO`);
    console.log(`üìè Input: bbox=(${bboxX}, ${bboxY}, ${bboxWidth}x${bboxHeight}), display=(${displayWidth}x${displayHeight})`);
    
    // Get EXACT video element dimensions
    const videoRect = video.getBoundingClientRect();
    const actualVideoWidth = video.videoWidth || 1920;
    const actualVideoHeight = video.videoHeight || 1080;
    
    console.log(`üìê Video element rect: ${videoRect.width}x${videoRect.height}`);
    console.log(`üìê Video natural size: ${actualVideoWidth}x${actualVideoHeight}`);
    
    // DEMO-CRITICAL: Force coordinate detection based on data patterns
    let scaledX, scaledY, scaledWidth, scaledHeight;
    
    // Smart detection: if all values are <= 100, treat as percentage
    const isPercentage = bboxX <= 100 && bboxY <= 100 && bboxWidth <= 100 && bboxHeight <= 100;
    
    if (isPercentage) {
        console.log(`‚úÖ DEMO: Using PERCENTAGE mode - direct conversion`);
        // Direct percentage to pixel conversion
        scaledX = (bboxX / 100) * displayWidth;
        scaledY = (bboxY / 100) * displayHeight;
        scaledWidth = (bboxWidth / 100) * displayWidth;
        scaledHeight = (bboxHeight / 100) * displayHeight;
    } else {
        console.log(`‚úÖ DEMO: Using PIXEL mode - scaling from original resolution`);
        // Scale from original video resolution to display size
        const scaleFactorX = displayWidth / actualVideoWidth;
        const scaleFactorY = displayHeight / actualVideoHeight;
        
        scaledX = bboxX * scaleFactorX;
        scaledY = bboxY * scaleFactorY;
        scaledWidth = bboxWidth * scaleFactorX;
        scaledHeight = bboxHeight * scaleFactorY;
        
        console.log(`üîß DEMO: Scale factors X=${scaleFactorX.toFixed(4)}, Y=${scaleFactorY.toFixed(4)}`);
    }
    
    // DEMO CRITICAL: Apply manual correction offsets for perfect positioning
    const demoOffsets = getDemoCalibrationOffsets();
    scaledX += demoOffsets.x;
    scaledY += demoOffsets.y;
    scaledWidth *= demoOffsets.scaleX;
    scaledHeight *= demoOffsets.scaleY;
    
    console.log(`üéØ DEMO: Applied demo offsets: +${demoOffsets.x}, +${demoOffsets.y}, √ó${demoOffsets.scaleX}, √ó${demoOffsets.scaleY}`);
    
    // Apply any runtime calibration offsets
    if (window.calibrationOffsets) {
        const offsets = window.calibrationOffsets;
        scaledX += offsets.offsetX || 0;
        scaledY += offsets.offsetY || 0;
        scaledWidth *= offsets.scaleX || 1;
        scaledHeight *= offsets.scaleY || 1;
        console.log(`üîß Applied runtime calibration: X+${offsets.offsetX}, Y+${offsets.offsetY}`);
    }
    
    // Ensure coordinates are within bounds
    scaledX = Math.max(0, Math.min(scaledX, displayWidth - scaledWidth));
    scaledY = Math.max(0, Math.min(scaledY, displayHeight - scaledHeight));
    scaledWidth = Math.max(10, Math.min(scaledWidth, displayWidth - scaledX));
    scaledHeight = Math.max(10, Math.min(scaledHeight, displayHeight - scaledY));
    
    console.log(`üéØ DEMO FINAL: (${scaledX.toFixed(1)}, ${scaledY.toFixed(1)}, ${scaledWidth.toFixed(1)}x${scaledHeight.toFixed(1)})`);
    
    return { scaledX, scaledY, scaledWidth, scaledHeight };
}

function getDemoCalibrationOffsets() {
    // DEMO CRITICAL: Fine-tune these values for perfect positioning
    const video = document.getElementById('videoPlayer');
    const rect = video.getBoundingClientRect();
    
    // Determine offset based on current video size and browser
    let offsetX = 0;
    let offsetY = 0;
    let scaleX = 1.0;
    let scaleY = 1.0;
    
    // Browser-specific adjustments
    const userAgent = navigator.userAgent.toLowerCase();
    if (userAgent.includes('chrome')) {
        offsetY = -3; // Chrome tends to be slightly off vertically
    } else if (userAgent.includes('firefox')) {
        offsetY = -2;
        offsetX = 1;
    } else if (userAgent.includes('safari')) {
        offsetY = -4;
    }
    
    // Screen size adjustments
    if (rect.width < 600) {
        // Mobile
        offsetX += 2;
        offsetY += 1;
        scaleX = 0.98;
        scaleY = 0.97;
    } else if (rect.width > 1000) {
        // Large screen
        offsetX -= 1;
        offsetY -= 2;
        scaleX = 1.01;
        scaleY = 1.02;
    }
    
    // Apply manual demo offsets if available (for live adjustment during demo)
    if (window.demoManualOffsets) {
        offsetX += window.demoManualOffsets.x;
        offsetY += window.demoManualOffsets.y;
        scaleX *= window.demoManualOffsets.scaleX;
        scaleY *= window.demoManualOffsets.scaleY;
        console.log(`üéØ DEMO: Applied manual offsets: +${window.demoManualOffsets.x}, +${window.demoManualOffsets.y}`);
    }
    
    console.log(`üéØ DEMO FINAL offsets: X=${offsetX}, Y=${offsetY}, scaleX=${scaleX}, scaleY=${scaleY}`);
    
    return { x: offsetX, y: offsetY, scaleX, scaleY };
}

function toggleDemoDebugMode() {
    window.demoDebugMode = !window.demoDebugMode;
    
    if (window.demoDebugMode) {
        console.log('üéØ DEMO DEBUG MODE ACTIVATED for your boss demo!');
        
        // Initialize manual offsets if not exist
        if (!window.demoManualOffsets) {
            window.demoManualOffsets = { x: 0, y: 0, scaleX: 1.0, scaleY: 1.0 };
        }
        
        // Show debug overlay
        showDemoDebugOverlay();
        
        // Show current detection with debug info
        refreshCurrentDetectionWithDebug();
        
    } else {
        console.log('üéØ DEMO DEBUG MODE DEACTIVATED');
        hideDemoDebugOverlay();
    }
}

function showDemoDebugOverlay() {
    // Remove existing overlay
    const existing = document.getElementById('demoDebugOverlay');
    if (existing) existing.remove();
    
    // Create debug overlay
    const overlay = document.createElement('div');
    overlay.id = 'demoDebugOverlay';
    overlay.className = 'fixed top-20 right-4 z-50 bg-black bg-opacity-90 text-white p-4 rounded-lg shadow-lg max-w-sm';
    overlay.innerHTML = `
        <div class="text-lg font-bold text-yellow-300 mb-2">üéØ DEMO DEBUG MODE</div>
        <div class="text-sm space-y-1">
            <div><strong>Controls for perfect positioning:</strong></div>
            <div>‚Ä¢ Press 'D' to toggle this mode</div>
            <div>‚Ä¢ Arrow Up/Down: Move Y position</div>
            <div>‚Ä¢ Ctrl+Arrow Left/Right: Move X position</div>
            <div>‚Ä¢ Press 'R' to reset offsets</div>
            <div>‚Ä¢ Press 'S' to save current offsets</div>
        </div>
        <div class="mt-3 text-xs border-t border-gray-600 pt-2">
            <div id="debugOffsetDisplay">Manual Offsets: X=0, Y=0</div>
            <div id="debugVideoInfo">Video: Loading...</div>
        </div>
        <div class="mt-2">
            <button onclick="resetDemoOffsets()" class="bg-red-600 hover:bg-red-700 px-2 py-1 rounded text-xs mr-2">Reset</button>
            <button onclick="saveDemoOffsets()" class="bg-green-600 hover:bg-green-700 px-2 py-1 rounded text-xs">Save</button>
        </div>
    `;
    
    document.body.appendChild(overlay);
    updateDebugDisplay();
}

function hideDemoDebugOverlay() {
    const overlay = document.getElementById('demoDebugOverlay');
    if (overlay) overlay.remove();
}

function adjustDemoOffsets(deltaX, deltaY) {
    if (!window.demoManualOffsets) {
        window.demoManualOffsets = { x: 0, y: 0, scaleX: 1.0, scaleY: 1.0 };
    }
    
    window.demoManualOffsets.x += deltaX;
    window.demoManualOffsets.y += deltaY;
    
    console.log(`üéØ DEMO: Adjusted manual offsets to X=${window.demoManualOffsets.x}, Y=${window.demoManualOffsets.y}`);
    
    updateDebugDisplay();
    refreshCurrentDetectionWithDebug();
}

function resetDemoOffsets() {
    window.demoManualOffsets = { x: 0, y: 0, scaleX: 1.0, scaleY: 1.0 };
    console.log('üéØ DEMO: Reset manual offsets to zero');
    updateDebugDisplay();
    refreshCurrentDetectionWithDebug();
}

function saveDemoOffsets() {
    if (window.demoManualOffsets) {
        localStorage.setItem('demoManualOffsets', JSON.stringify(window.demoManualOffsets));
        console.log('üéØ DEMO: Saved manual offsets to localStorage');
        
        // Show save confirmation
        const notification = document.createElement('div');
        notification.className = 'fixed top-4 left-1/2 transform -translate-x-1/2 z-50 bg-green-100 border border-green-400 text-green-700 px-4 py-2 rounded';
        notification.textContent = '‚úÖ Demo offsets saved!';
        document.body.appendChild(notification);
        
        setTimeout(() => notification.remove(), 2000);
    }
}

function loadDemoOffsets() {
    try {
        const saved = localStorage.getItem('demoManualOffsets');
        if (saved) {
            window.demoManualOffsets = JSON.parse(saved);
            console.log('üéØ DEMO: Loaded saved manual offsets:', window.demoManualOffsets);
        }
    } catch (e) {
        console.log('üéØ DEMO: No saved offsets found');
    }
}

function updateDebugDisplay() {
    const offsetDisplay = document.getElementById('debugOffsetDisplay');
    const videoInfo = document.getElementById('debugVideoInfo');
    
    if (offsetDisplay && window.demoManualOffsets) {
        offsetDisplay.textContent = `Manual Offsets: X=${window.demoManualOffsets.x}, Y=${window.demoManualOffsets.y}`;
    }
    
    if (videoInfo) {
        const video = document.getElementById('videoPlayer');
        if (video) {
            const rect = video.getBoundingClientRect();
            videoInfo.textContent = `Video: ${rect.width.toFixed(0)}√ó${rect.height.toFixed(0)}px`;
        }
    }
}

function refreshCurrentDetectionWithDebug() {
    // Find currently highlighted detection and refresh its bounding box
    const highlighted = document.querySelector('.detection-item.bg-blue-100');
    if (highlighted) {
        const detectionId = highlighted.dataset.detectionId;
        const timestamp = parseFloat(highlighted.dataset.timestamp);
        const bboxX = parseInt(highlighted.dataset.bboxX);
        const bboxY = parseInt(highlighted.dataset.bboxY);
        const bboxWidth = parseInt(highlighted.dataset.bboxWidth);
        const bboxHeight = parseInt(highlighted.dataset.bboxHeight);
        
        console.log('üéØ DEMO: Refreshing detection with debug offsets');
        
        // Remove existing box and redraw with new offsets
        const existingBox = document.getElementById('boundingBox');
        if (existingBox) existingBox.remove();
        
        showEnhancedBoundingBox(bboxX, bboxY, bboxWidth, bboxHeight, timestamp, detectionId);
    }
}

function isPercentageCoordinates(x, y, width, height) {
    // Heuristic to detect if coordinates are percentages vs pixels
    // Percentage coordinates should be between 0-100
    // Pixel coordinates will typically be larger for modern videos
    
    const maxCoordinate = Math.max(x, y, width, height);
    const allSmall = x <= 100 && y <= 100 && width <= 100 && height <= 100;
    const typicalPercentageRange = maxCoordinate <= 100 && maxCoordinate > 0;
    
    console.log(`üîç Coordinate analysis: max=${maxCoordinate}, allSmall=${allSmall}, typicalRange=${typicalPercentageRange}`);
    
    // If all coordinates are <= 100, likely percentages
    // If any coordinate > 100, likely pixels
    return allSmall && typicalPercentageRange;
}

function testBoundingBoxScaling() {
    console.log('üß™ Testing bounding box scaling...');
    
    const video = document.getElementById('videoPlayer');
    if (!video) {
        console.error('‚ùå Video player not found for testing');
        return;
    }
    
    // Wait for video to load
    if (video.readyState < 1) {
        console.log('‚è≥ Waiting for video metadata for testing...');
        video.addEventListener('loadedmetadata', testBoundingBoxScaling, { once: true });
        return;
    }
    
    console.log('üìä Video Test Info:');
    console.log(`  Browser video size: ${video.videoWidth}x${video.videoHeight}`);
    console.log(`  Backend resolution: ${video.dataset.originalWidth}x${video.dataset.originalHeight}`);
    console.log(`  Display size: ${video.offsetWidth}x${video.offsetHeight}`);
    
    // Test both percentage and pixel coordinates
    const testCases = [
        { name: 'Percentage (center)', x: 50, y: 50, w: 10, h: 20 },
        { name: 'Percentage (top-left)', x: 10, y: 15, w: 25, h: 30 },
        { name: 'Pixel (if 1920x1080)', x: 960, y: 540, w: 192, h: 216 },
        { name: 'Pixel (if 1920x1080)', x: 384, y: 270, w: 480, h: 324 }
    ];
    
    const videoRect = video.getBoundingClientRect();
    const displayWidth = videoRect.width;
    const displayHeight = videoRect.height;
    
    testCases.forEach(test => {
        console.log(`\nüß™ Testing ${test.name}:`);
        const result = convertBoundingBoxCoordinates(
            test.x, test.y, test.w, test.h,
            video, displayWidth, displayHeight
        );
        console.log(`  Result: (${result.scaledX.toFixed(1)}, ${result.scaledY.toFixed(1)}, ${result.scaledWidth.toFixed(1)}x${result.scaledHeight.toFixed(1)})`);
    });
    
    console.log('‚úÖ Bounding box scaling test completed');
}

async function calibrateBoundingBoxes(detectionId = null) {
    console.log('üéØ Starting AI-powered bounding box calibration...');
    
    const video = document.getElementById('videoPlayer');
    if (!video || video.readyState < 1) {
        console.error('‚ùå Video not ready for calibration');
        return;
    }
    
    try {
        // Step 1: Capture current video frame
        const frameCapture = await captureVideoFrame(video);
        console.log('üì∏ Video frame captured for calibration');
        
        // Step 2: Get detection coordinates for calibration
        const calibrationData = await prepareCalibrationData(detectionId);
        console.log('üìä Calibration data prepared:', calibrationData);
        
        // Step 3: Send to backend for AI re-detection and calibration
        const calibrationResult = await performAICalibration(frameCapture, calibrationData);
        console.log('ü§ñ AI calibration completed:', calibrationResult);
        
        // Step 4: Apply calibration offsets globally
        if (calibrationResult.success) {
            applyCalibrationOffsets(calibrationResult.offsets);
            console.log('‚úÖ Calibration offsets applied to all detections');
            
            // Show success notification
            showCalibrationNotification('‚úÖ Bounding box calibration completed! Boxes should now be more accurate.');
        } else {
            console.error('‚ùå Calibration failed:', calibrationResult.error);
            showCalibrationNotification('‚ùå Calibration failed. Please try again.', 'error');
        }
        
    } catch (error) {
        console.error('‚ùå Calibration error:', error);
        showCalibrationNotification('‚ùå Calibration error: ' + error.message, 'error');
    }
}

async function captureVideoFrame(video) {
    console.log('üì∏ Capturing current video frame...');
    
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    // Get actual video display dimensions
    const videoRect = video.getBoundingClientRect();
    const videoAspectRatio = video.videoWidth / video.videoHeight;
    const containerAspectRatio = videoRect.width / videoRect.height;
    
    let displayWidth, displayHeight, offsetX, offsetY;
    
    if (containerAspectRatio > videoAspectRatio) {
        // Video is pillarboxed
        displayHeight = videoRect.height;
        displayWidth = displayHeight * videoAspectRatio;
        offsetX = (videoRect.width - displayWidth) / 2;
        offsetY = 0;
    } else {
        // Video is letterboxed
        displayWidth = videoRect.width;
        displayHeight = displayWidth / videoAspectRatio;
        offsetX = 0;
        offsetY = (videoRect.height - displayHeight) / 2;
    }
    
    // Set canvas to actual displayed video size
    canvas.width = displayWidth;
    canvas.height = displayHeight;
    
    // Draw the video frame to canvas
    ctx.drawImage(video, 0, 0, displayWidth, displayHeight);
    
    // Convert to base64 for transmission
    const frameData = canvas.toDataURL('image/jpeg', 0.9);
    
    console.log(`üìä Frame captured: ${displayWidth}x${displayHeight} (offset: ${offsetX}, ${offsetY})`);
    
    return {
        frameData,
        displayWidth,
        displayHeight,
        offsetX,
        offsetY,
        timestamp: video.currentTime,
        originalVideoWidth: video.videoWidth,
        originalVideoHeight: video.videoHeight
    };
}

async function prepareCalibrationData(detectionId) {
    console.log('üìä Preparing calibration data...');
    
    const detections = [];
    const detectionItems = document.querySelectorAll('.detection-item[data-detection-id]');
    
    detectionItems.forEach(item => {
        const data = {
            id: parseInt(item.dataset.detectionId),
            timestamp: parseFloat(item.dataset.timestamp),
            frameNumber: parseInt(item.dataset.frameNumber) || null,
            bbox: {
                x: parseInt(item.dataset.bboxX),
                y: parseInt(item.dataset.bboxY),
                width: parseInt(item.dataset.bboxWidth),
                height: parseInt(item.dataset.bboxHeight)
            }
        };
        
        // If specific detection requested, include only that one
        if (detectionId === null || data.id === detectionId) {
            detections.push(data);
        }
    });
    
    console.log(`üìä Prepared ${detections.length} detections for calibration`);
    return {
        videoId: {{ video.id }},
        detections,
        targetDetectionId: detectionId
    };
}

async function performAICalibration(frameCapture, calibrationData) {
    console.log('ü§ñ Sending calibration request to AI backend...');
    
    const requestData = {
        frameData: frameCapture.frameData,
        frameInfo: {
            displayWidth: frameCapture.displayWidth,
            displayHeight: frameCapture.displayHeight,
            offsetX: frameCapture.offsetX,
            offsetY: frameCapture.offsetY,
            timestamp: frameCapture.timestamp,
            originalVideoWidth: frameCapture.originalVideoWidth,
            originalVideoHeight: frameCapture.originalVideoHeight
        },
        calibrationData
    };
    
    try {
        const response = await fetch(`/videos/api/${calibrationData.videoId}/calibrate-coordinates`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(requestData)
        });
        
        if (!response.ok) {
            throw new Error(`Calibration API error: ${response.status} ${response.statusText}`);
        }
        
        const result = await response.json();
        console.log('ü§ñ AI calibration response:', result);
        
        return result;
        
    } catch (error) {
        console.error('‚ùå AI calibration request failed:', error);
        throw error;
    }
}

function applyCalibrationOffsets(offsets) {
    console.log('üîß Applying calibration offsets:', offsets);
    
    // Store calibration offsets globally for this session
    window.calibrationOffsets = offsets;
    
    // Update all existing bounding boxes
    const existingBox = document.getElementById('boundingBox');
    if (existingBox) {
        existingBox.remove();
    }
    
    // Refresh any visible detection highlights
    const highlightedDetection = document.querySelector('.detection-item.bg-blue-100');
    if (highlightedDetection) {
        const detectionId = highlightedDetection.dataset.detectionId;
        const timestamp = parseFloat(highlightedDetection.dataset.timestamp);
        const bboxX = parseInt(highlightedDetection.dataset.bboxX);
        const bboxY = parseInt(highlightedDetection.dataset.bboxY);
        const bboxWidth = parseInt(highlightedDetection.dataset.bboxWidth);
        const bboxHeight = parseInt(highlightedDetection.dataset.bboxHeight);
        
        console.log('üîÑ Refreshing highlighted detection with calibrated coordinates');
        showEnhancedBoundingBox(bboxX, bboxY, bboxWidth, bboxHeight, timestamp, detectionId);
    }
    
    console.log('‚úÖ Calibration offsets applied successfully');
}

function showCalibrationNotification(message, type = 'success') {
    // Create notification element
    const notification = document.createElement('div');
    notification.className = `fixed top-4 right-4 z-50 p-4 rounded-lg shadow-lg max-w-sm ${
        type === 'error' ? 'bg-red-100 border border-red-400 text-red-700' : 'bg-green-100 border border-green-400 text-green-700'
    }`;
    notification.innerHTML = `
        <div class="flex items-center">
            <div class="flex-1">${message}</div>
            <button onclick="this.parentElement.parentElement.remove()" class="ml-2 text-lg font-semibold">&times;</button>
        </div>
    `;
    
    document.body.appendChild(notification);
    
    // Auto-remove after 5 seconds
    setTimeout(() => {
        if (notification.parentElement) {
            notification.remove();
        }
    }, 5000);
}

function highlightDetectionInNavigator(detectionId) {
    console.log(`üéØ Highlighting detection ${detectionId} in navigator`);
    
    // Remove existing highlights
    const allItems = document.querySelectorAll('.detection-item');
    allItems.forEach(item => {
        item.classList.remove('bg-blue-100', 'border-blue-300');
    });
    
    // Find and highlight the detection item
    const targetItem = document.querySelector(`.detection-item[data-detection-id="${detectionId}"]`);
    if (targetItem) {
        targetItem.classList.add('bg-blue-100', 'border-blue-300');
        
        // Scroll into view smoothly
        targetItem.scrollIntoView({ 
            behavior: 'smooth', 
            block: 'center' 
        });
        
        console.log(`‚úÖ Highlighted detection ${detectionId} in navigator`);
    } else {
        console.warn(`‚ö†Ô∏è Detection item ${detectionId} not found in navigator`);
    }
}

function showEnhancedBoundingBox(bboxX, bboxY, bboxWidth, bboxHeight, timestamp, detectionId) {
    console.log(`üì¶ Showing enhanced bounding box for PERSON-${String(detectionId).padStart(4, '0')}`);
    
    const video = document.getElementById('videoPlayer');
    if (!video) {
        console.error('‚ùå Video element not found for bounding box');
        return;
    }
    
    // Wait for video to be ready
    if (video.readyState < 1 || video.videoWidth === 0) {
        console.log('‚è≥ Waiting for video to load before showing bounding box...');
        video.addEventListener('loadedmetadata', function() {
            showEnhancedBoundingBox(bboxX, bboxY, bboxWidth, bboxHeight, timestamp, detectionId);
        }, { once: true });
        return;
    }
    
    // Remove existing bounding box
    const existingBox = document.getElementById('boundingBox');
    if (existingBox) {
        existingBox.remove();
    }
    
    // Get video container
    const videoContainer = video.parentElement;
    if (!videoContainer) {
        console.error('‚ùå Video container not found');
        return;
    }
    
    // Position the container relatively
    videoContainer.style.position = 'relative';
    
    // Create enhanced bounding box overlay
    const boundingBox = document.createElement('div');
    boundingBox.id = 'boundingBox';
    boundingBox.style.position = 'absolute';
    boundingBox.style.border = '3px solid #ef4444';
    boundingBox.style.background = 'rgba(239, 68, 68, 0.15)';
    boundingBox.style.pointerEvents = 'none';
    boundingBox.style.zIndex = '10';
    boundingBox.style.borderRadius = '4px';
    boundingBox.style.transition = 'all 0.3s ease';
    
    // Add enhanced label with person ID
    const label = document.createElement('div');
    label.style.position = 'absolute';
    label.style.top = '-30px';
    label.style.left = '0';
    label.style.background = '#ef4444';
    label.style.color = 'white';
    label.style.padding = '4px 8px';
    label.style.fontSize = '14px';
    label.style.fontWeight = 'bold';
    label.style.borderRadius = '4px';
    label.style.whiteSpace = 'nowrap';
    label.style.boxShadow = '0 2px 4px rgba(0,0,0,0.3)';
    label.textContent = `PERSON-${String(detectionId).padStart(4, '0')}`;
    boundingBox.appendChild(label);
    
    // Function to update bounding box position and size
    function updateBoundingBox() {
        const videoRect = video.getBoundingClientRect();
        const containerRect = videoContainer.getBoundingClientRect();
        
        // Calculate actual video display dimensions (accounting for aspect ratio)
        const videoAspectRatio = video.videoWidth / video.videoHeight;
        const containerAspectRatio = videoRect.width / videoRect.height;
        
        let displayWidth, displayHeight, offsetX, offsetY;
        
        if (containerAspectRatio > videoAspectRatio) {
            // Video is pillarboxed (black bars on sides)
            displayHeight = videoRect.height;
            displayWidth = displayHeight * videoAspectRatio;
            offsetX = (videoRect.width - displayWidth) / 2;
            offsetY = 0;
        } else {
            // Video is letterboxed (black bars on top/bottom)
            displayWidth = videoRect.width;
            displayHeight = displayWidth / videoAspectRatio;
            offsetX = 0;
            offsetY = (videoRect.height - displayHeight) / 2;
        }
        
        // Smart coordinate conversion (handles both percentage and pixel coordinates)
        const { scaledX, scaledY, scaledWidth, scaledHeight } = convertBoundingBoxCoordinates(
            bboxX, bboxY, bboxWidth, bboxHeight, 
            video, displayWidth, displayHeight
        );
        
        const boxLeft = offsetX + scaledX;
        const boxTop = offsetY + scaledY;
        const boxWidth = scaledWidth;
        const boxHeight = scaledHeight;
        
        boundingBox.style.left = `${boxLeft}px`;
        boundingBox.style.top = `${boxTop}px`;
        boundingBox.style.width = `${boxWidth}px`;
        boundingBox.style.height = `${boxHeight}px`;
        
        console.log(`üìè Enhanced bbox positioned: ${boxLeft.toFixed(1)}, ${boxTop.toFixed(1)}, ${boxWidth.toFixed(1)}x${boxHeight.toFixed(1)}`);
    }
    
    videoContainer.appendChild(boundingBox);
    
    // Update position when video metadata loads
    if (video.readyState >= 1) {
        updateBoundingBox();
    } else {
        video.addEventListener('loadedmetadata', updateBoundingBox, { once: true });
    }
    
    // Update position on window resize
    const resizeHandler = () => updateBoundingBox();
    window.addEventListener('resize', resizeHandler);
    
    // Blink effect - flash the box for 1 second
    let blinkCount = 0;
    const blinkInterval = setInterval(() => {
        boundingBox.style.opacity = boundingBox.style.opacity === '0' ? '1' : '0';
        blinkCount++;
        if (blinkCount >= 4) { // 2 full blinks (4 opacity changes)
            clearInterval(blinkInterval);
            boundingBox.style.opacity = '1';
        }
    }, 250);
    
    // Auto-hide bounding box after 8 seconds
    setTimeout(() => {
        if (boundingBox && boundingBox.parentElement) {
            boundingBox.style.opacity = '0';
            setTimeout(() => {
                if (boundingBox && boundingBox.parentElement) {
                    boundingBox.remove();
                    window.removeEventListener('resize', resizeHandler);
                }
            }, 300);
        }
    }, 8000);
    
    console.log(`‚úÖ Enhanced bounding box displayed for PERSON-${String(detectionId).padStart(4, '0')}`);
}

function updateTimeDisplay() {
    const video = document.getElementById('videoPlayer');
    const currentTimeDisplay = document.getElementById('currentTimeDisplay');
    const durationDisplay = document.getElementById('durationDisplay');
    
    if (video && currentTimeDisplay) {
        currentTimeDisplay.textContent = formatTimestamp(video.currentTime);
    }
    
    if (video && durationDisplay && video.duration) {
        durationDisplay.textContent = formatTimestamp(video.duration);
    }
}

function updateDetectionCounter() {
    const video = document.getElementById('videoPlayer');
    const detectionCounter = document.getElementById('detectionCounter');
    
    if (!video || !detectionCounter) return;
    
    const currentTime = video.currentTime;
    const tolerance = 1.0; // 1 second tolerance
    
    // Find detections near current time
    const detectionItems = document.querySelectorAll('.detection-item');
    let activeDetection = null;
    
    detectionItems.forEach(item => {
        const timestamp = parseFloat(item.dataset.timestamp);
        if (Math.abs(currentTime - timestamp) <= tolerance) {
            if (!activeDetection || Math.abs(currentTime - timestamp) < Math.abs(currentTime - parseFloat(activeDetection.dataset.timestamp))) {
                activeDetection = item;
            }
        }
    });
    
    if (activeDetection) {
        const detectionId = activeDetection.dataset.detectionId;
        const timestamp = parseFloat(activeDetection.dataset.timestamp);
        detectionCounter.textContent = `PERSON-${String(detectionId).padStart(4, '0')} at ${timestamp.toFixed(1)}s`;
        detectionCounter.className = 'text-green-600 font-medium';
        
        // Highlight the row
        highlightDetectionInNavigator(detectionId);
    } else {
        detectionCounter.textContent = 'No detection at current frame';
        detectionCounter.className = 'text-gray-500';
        
        // Remove highlights
        const allItems = document.querySelectorAll('.detection-item');
        allItems.forEach(item => {
            item.classList.remove('bg-blue-100', 'border-blue-300');
        });
    }
}

// Legacy function for compatibility
function highlightDetectionRow(detectionId) {
    // Remove existing highlights
    const allRows = document.querySelectorAll('tbody tr');
    allRows.forEach(row => {
        row.classList.remove('bg-blue-50', 'border-blue-200');
    });
    
    // Find and highlight the current detection row
    // This is a simple approach - in production you might want to add data attributes
    const rows = document.querySelectorAll('tbody tr');
    const detectionIndex = Array.from(rows).findIndex(row => {
        const actionCell = row.querySelector('td:last-child');
        return actionCell && actionCell.innerHTML.includes(`identifyPerson(${detectionId})`);
    });
    
    if (detectionIndex >= 0 && rows[detectionIndex]) {
        rows[detectionIndex].classList.add('bg-blue-50', 'border-blue-200');
        rows[detectionIndex].scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }
}

function showBoundingBox(bboxX, bboxY, bboxWidth, bboxHeight, timestamp) {
    console.log(`üì¶ Showing bounding box: ${bboxX}, ${bboxY}, ${bboxWidth}x${bboxHeight}`);
    
    const video = document.getElementById('videoPlayer');
    if (!video) {
        console.error('‚ùå Video element not found for bounding box');
        return;
    }
    
    // Wait for video to be ready
    if (video.readyState < 1 || video.videoWidth === 0) {
        console.log('‚è≥ Waiting for video to load before showing bounding box...');
        video.addEventListener('loadedmetadata', function() {
            showBoundingBox(bboxX, bboxY, bboxWidth, bboxHeight, timestamp);
        }, { once: true });
        return;
    }
    
    // Remove existing bounding box
    const existingBox = document.getElementById('boundingBox');
    if (existingBox) {
        existingBox.remove();
    }
    
    // Get video container
    const videoContainer = video.parentElement;
    if (!videoContainer) {
        console.error('‚ùå Video container not found');
        return;
    }
    
    // Create bounding box overlay
    const boundingBox = document.createElement('div');
    boundingBox.id = 'boundingBox';
    boundingBox.style.position = 'absolute';
    boundingBox.style.border = '3px solid #ef4444';
    boundingBox.style.background = 'rgba(239, 68, 68, 0.1)';
    boundingBox.style.pointerEvents = 'none';
    boundingBox.style.zIndex = '10';
    boundingBox.style.borderRadius = '4px';
    boundingBox.style.transition = 'all 0.3s ease';
    
    // Add label
    const label = document.createElement('div');
    label.style.position = 'absolute';
    label.style.top = '-25px';
    label.style.left = '0';
    label.style.background = '#ef4444';
    label.style.color = 'white';
    label.style.padding = '2px 6px';
    label.style.fontSize = '12px';
    label.style.borderRadius = '4px';
    label.style.whiteSpace = 'nowrap';
    label.textContent = `Person at ${timestamp.toFixed(1)}s`;
    boundingBox.appendChild(label);
    
    // Position the container relatively
    videoContainer.style.position = 'relative';
    
    // Function to update bounding box position and size
    function updateBoundingBox() {
        const videoRect = video.getBoundingClientRect();
        const containerRect = videoContainer.getBoundingClientRect();
        
        // Calculate actual video display dimensions (accounting for aspect ratio)
        const videoAspectRatio = video.videoWidth / video.videoHeight;
        const containerAspectRatio = videoRect.width / videoRect.height;
        
        let displayWidth, displayHeight, offsetX, offsetY;
        
        if (containerAspectRatio > videoAspectRatio) {
            // Video is pillarboxed (black bars on sides)
            displayHeight = videoRect.height;
            displayWidth = displayHeight * videoAspectRatio;
            offsetX = (videoRect.width - displayWidth) / 2;
            offsetY = 0;
        } else {
            // Video is letterboxed (black bars on top/bottom)
            displayWidth = videoRect.width;
            displayHeight = displayWidth / videoAspectRatio;
            offsetX = 0;
            offsetY = (videoRect.height - displayHeight) / 2;
        }
        
        // Smart coordinate conversion (handles both percentage and pixel coordinates)
        const { scaledX, scaledY, scaledWidth, scaledHeight } = convertBoundingBoxCoordinates(
            bboxX, bboxY, bboxWidth, bboxHeight, 
            video, displayWidth, displayHeight
        );
        
        const boxLeft = offsetX + scaledX;
        const boxTop = offsetY + scaledY;
        const boxWidth = scaledWidth;
        const boxHeight = scaledHeight;
        
        // Position relative to video container
        boundingBox.style.left = `${boxLeft}px`;
        boundingBox.style.top = `${boxTop}px`;
        boundingBox.style.width = `${boxWidth}px`;
        boundingBox.style.height = `${boxHeight}px`;
    }
    
    // Add bounding box to container
    videoContainer.appendChild(boundingBox);
    
    // Update position when video metadata loads
    if (video.readyState >= 1) {
        updateBoundingBox();
    } else {
        video.addEventListener('loadedmetadata', updateBoundingBox, { once: true });
    }
    
    // Update position on window resize
    window.addEventListener('resize', updateBoundingBox);
    
    // Auto-hide bounding box after 10 seconds
    setTimeout(() => {
        if (boundingBox && boundingBox.parentElement) {
            boundingBox.style.opacity = '0';
            setTimeout(() => {
                if (boundingBox && boundingBox.parentElement) {
                    boundingBox.remove();
                }
            }, 300);
        }
    }, 10000);
    
    // Hide bounding box when video time changes significantly
    let lastTime = timestamp;
    function checkVideoTime() {
        if (Math.abs(video.currentTime - lastTime) > 2) {
            if (boundingBox && boundingBox.parentElement) {
                boundingBox.style.opacity = '0';
                setTimeout(() => {
                    if (boundingBox && boundingBox.parentElement) {
                        boundingBox.remove();
                    }
                }, 300);
            }
            video.removeEventListener('timeupdate', checkVideoTime);
        }
    }
    video.addEventListener('timeupdate', checkVideoTime);
}

function identifyPerson(detectionId) {
    console.log(`üë§ Identifying person in detection ${detectionId}`);
    
    // Simple identification modal (you can enhance this)
    const employeeName = prompt('Enter employee name for identification:');
    
    if (employeeName && employeeName.trim()) {
        console.log(`‚úÖ Identifying detection ${detectionId} as: ${employeeName}`);
        
        // Here you would typically make an API call to save the identification
        // For now, we'll just show a success message
        alert(`Person identified as: ${employeeName}\n\nNote: Full identification functionality requires backend API implementation.`);
        
        // You could implement this API call:
        /*
        fetch(`/api/detections/${detectionId}/identify`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                employee_name: employeeName
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                // Refresh the page or update the UI
                location.reload();
            }
        });
        */
    }
}

// Helper function to format timestamp for display
function formatTimestamp(seconds) {
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = Math.floor(seconds % 60);
    return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
}

// Test function to simulate progress updates (Development/Debug only)
function testProgressUI() {
    console.log('üß™ Testing progress UI updates...');
    
    const progressSteps = [
        { progress: 10, message: 'Extracting video metadata...' },
        { progress: 25, message: 'Initializing person detection...' },
        { progress: 40, message: 'Analyzing video frames...' },
        { progress: 60, message: 'Detecting persons in video...' },
        { progress: 75, message: 'Processing detection results...' },
        { progress: 90, message: 'Saving detection data...' },
        { progress: 100, message: 'Person extraction completed!' }
    ];
    
    let stepIndex = 0;
    const testInterval = setInterval(() => {
        if (stepIndex >= progressSteps.length) {
            clearInterval(testInterval);
            console.log('üß™ Progress UI test completed');
            return;
        }
        
        const step = progressSteps[stepIndex];
        const testData = {
            status: stepIndex === progressSteps.length - 1 ? 'completed' : 'processing',
            progress: step.progress,
            progress_message: step.message
        };
        
        console.log(`üß™ Test step ${stepIndex + 1}: ${step.progress}% - ${step.message}`);
        updateProcessingUI(testData);
        
        stepIndex++;
    }, 1000); // Update every second for testing
}

// Add keyboard shortcuts for detection navigation
document.addEventListener('keydown', function(event) {
    // Only work when video is focused or no input is focused
    if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') {
        return;
    }
    
    const video = document.getElementById('videoPlayer');
    if (!video) return;
    
    switch(event.key) {
        case 'ArrowLeft':
            // Jump backward 5 seconds
            video.currentTime = Math.max(0, video.currentTime - 5);
            event.preventDefault();
            break;
        case 'ArrowRight':
            // Jump forward 5 seconds
            video.currentTime = Math.min(video.duration, video.currentTime + 5);
            event.preventDefault();
            break;
        case ' ':
            // Space to play/pause
            if (video.paused) {
                video.play();
            } else {
                video.pause();
            }
            event.preventDefault();
            break;
        case 't':
            // 'T' key to test bounding box scaling
            testBoundingBoxScaling();
            event.preventDefault();
            break;
        case 'c':
            // 'C' key to calibrate all bounding boxes
            calibrateBoundingBoxes();
            event.preventDefault();
            break;
        case 'd':
            // 'D' key to toggle demo debug mode
            toggleDemoDebugMode();
            event.preventDefault();
            break;
        case 'ArrowUp':
            // Arrow keys for manual fine-tuning in demo mode
            if (window.demoDebugMode) {
                adjustDemoOffsets(0, -1);
                event.preventDefault();
            }
            break;
        case 'ArrowDown':
            if (window.demoDebugMode) {
                adjustDemoOffsets(0, 1);
                event.preventDefault();
            }
            break;
        case 'ArrowLeft':
            if (window.demoDebugMode && event.ctrlKey) {
                adjustDemoOffsets(-1, 0);
                event.preventDefault();
            }
            break;
        case 'ArrowRight':
            if (window.demoDebugMode && event.ctrlKey) {
                adjustDemoOffsets(1, 0);
                event.preventDefault();
            }
            break;
        case 'r':
            // 'R' key to reset demo offsets
            if (window.demoDebugMode) {
                resetDemoOffsets();
                event.preventDefault();
            }
            break;
        case 's':
            // 'S' key to save demo offsets
            if (window.demoDebugMode) {
                saveDemoOffsets();
                event.preventDefault();
            }
            break;
    }
});

// Enhanced video time tracking for detection highlighting
function setupVideoTimeTracking() {
    const video = document.getElementById('videoPlayer');
    if (!video) return;
    
    let lastHighlightedDetection = null;
    
    video.addEventListener('timeupdate', function() {
        const currentTime = video.currentTime;
        updateTimeDisplay(currentTime);
        
        // Find detection closest to current time (within 2 seconds)
        const detectionItems = document.querySelectorAll('.detection-item[data-timestamp]');
        let closestDetection = null;
        let closestTimeDiff = Infinity;
        
        detectionItems.forEach(item => {
            const timestamp = parseFloat(item.dataset.timestamp);
            const timeDiff = Math.abs(currentTime - timestamp);
            
            // Within 2 seconds and closer than previous
            if (timeDiff <= 2 && timeDiff < closestTimeDiff) {
                closestDetection = item;
                closestTimeDiff = timeDiff;
            }
        });
        
        // Highlight the closest detection if found and different from last highlighted
        if (closestDetection && closestDetection !== lastHighlightedDetection) {
            const detectionId = closestDetection.dataset.detectionId;
            
            // Remove previous highlights
            detectionItems.forEach(item => {
                item.classList.remove('bg-blue-100', 'border-blue-300', 'ring-2', 'ring-blue-200');
            });
            
            // Highlight current detection
            closestDetection.classList.add('bg-blue-100', 'border-blue-300', 'ring-2', 'ring-blue-200');
            
            // Update detection counter
            updateDetectionCounter(parseInt(detectionId), currentTime);
            
            lastHighlightedDetection = closestDetection;
            
            console.log(`üéØ Auto-highlighted PERSON-${String(detectionId).padStart(4, '0')} at ${currentTime.toFixed(1)}s`);
        } else if (!closestDetection && lastHighlightedDetection) {
            // Clear highlight when no detection is close
            detectionItems.forEach(item => {
                item.classList.remove('bg-blue-100', 'border-blue-300', 'ring-2', 'ring-blue-200');
            });
            
            const counter = document.getElementById('detectionCounter');
            if (counter) {
                counter.textContent = 'No detection at current frame';
                counter.className = 'text-gray-600 font-medium';
            }
            
            lastHighlightedDetection = null;
        }
    });
    
    console.log('üé¨ Enhanced video time tracking initialized');
}

// Initialize debug panel visibility
document.addEventListener('DOMContentLoaded', function() {
    const videoStatus = '{{ video.status }}';
    const debugPanel = document.getElementById('debugPanel');
    
    // Show debug panel by default when converting
    if (videoStatus === 'converting' && debugPanel) {
        debugPanel.classList.remove('hidden');
        console.log('üîß Debug panel initialized and visible');
    }
    
    // Initialize enhanced video time tracking
    setupVideoTimeTracking();
    
    // Load saved demo offsets for perfect positioning
    loadDemoOffsets();
    console.log('üéØ DEMO: System ready for boss demo - press D for debug mode');
    
    // Log available detections for debugging
    const detectionRows = document.querySelectorAll('tbody tr');
    console.log(`üìä Found ${detectionRows.length} detection rows in table`);
    
    // Add fallback event handlers for detection buttons using data attributes
    document.addEventListener('click', function(event) {
        const button = event.target.closest('button[data-detection-id]');
        if (button && button.textContent.includes('üéØ Go to Frame')) {
            event.preventDefault();
            
            const detectionId = parseInt(button.dataset.detectionId);
            const timestamp = parseFloat(button.dataset.timestamp);
            const bboxX = parseInt(button.dataset.bboxX);
            const bboxY = parseInt(button.dataset.bboxY);
            const bboxWidth = parseInt(button.dataset.bboxWidth);
            const bboxHeight = parseInt(button.dataset.bboxHeight);
            
            console.log('üîÑ Using fallback event handler for jumpToDetection');
            jumpToDetection(timestamp, detectionId, bboxX, bboxY, bboxWidth, bboxHeight);
        }
    });
});

// Debug function to test video endpoints
async function debugVideoEndpoints() {
    const video = document.getElementById('videoPlayer');
    if (!video) {
        console.error('No video element found');
        return;
    }
    
    const sources = video.querySelectorAll('source');
    console.log(`üîç Testing ${sources.length} video sources...`);
    
    for (let i = 0; i < sources.length; i++) {
        const source = sources[i];
        const url = source.src;
        console.log(`\nüìπ Testing source ${i + 1}: ${url}`);
        
        try {
            // Try HEAD request first
            const headResponse = await fetch(url, { method: 'HEAD' });
            console.log(`   HEAD status: ${headResponse.status} ${headResponse.statusText}`);
            console.log(`   Content-Type: ${headResponse.headers.get('Content-Type')}`);
            console.log(`   Content-Length: ${headResponse.headers.get('Content-Length')}`);
            console.log(`   Accept-Ranges: ${headResponse.headers.get('Accept-Ranges')}`);
            
            // Try range request
            const rangeResponse = await fetch(url, {
                headers: { 'Range': 'bytes=0-1023' }
            });
            console.log(`   Range request status: ${rangeResponse.status}`);
            
            // Test the test endpoint if available
            const filename = url.split('/').pop();
            const testUrl = `/videos/test/${filename}`;
            console.log(`   Testing diagnostic endpoint: ${testUrl}`);
            try {
                const testResponse = await fetch(testUrl);
                if (testResponse.ok) {
                    const testData = await testResponse.text();
                    console.log(`   Diagnostic info:`, testData);
                }
            } catch (e) {
                console.log(`   Diagnostic endpoint error: ${e.message}`);
            }
            
        } catch (error) {
            console.error(`   ‚ùå Error testing source: ${error.message}`);
        }
    }
}

// Run debug on page load if video exists
document.addEventListener('DOMContentLoaded', function() {
    const video = document.getElementById('videoPlayer');
    if (video && !video.src) {
        console.log('üîß Video element found but not playing. Run debugVideoEndpoints() to diagnose.');
        
        // Check if this is a detected video
        if (video.dataset.videoType === 'detected') {
            console.log('üéØ This is a detected video with path:', video.dataset.videoPath);
            console.log('üí° Try running: testDetectedVideo()');
        }
    }
});

// Test function specifically for detected videos
function testDetectedVideo() {
    const video = document.getElementById('videoPlayer');
    if (!video || video.dataset.videoType !== 'detected') {
        console.error('No detected video found');
        return;
    }
    
    const videoPath = video.dataset.videoPath;
    console.log('üé¨ Testing detected video:', videoPath);
    
    // Try different approaches
    const testUrls = [
        `/videos/detected/${videoPath}`,
        `/videos/serve-annotated/${videoPath}`,
        `/processing/outputs/${videoPath}`,
        `/static/uploads/${videoPath}`
    ];
    
    console.log('üîç Testing multiple endpoints...');
    testUrls.forEach(async (url, index) => {
        try {
            const response = await fetch(url, { method: 'HEAD' });
            console.log(`${index + 1}. ${url} - Status: ${response.status} ${response.statusText}`);
            if (response.ok) {
                console.log(`   ‚úÖ This endpoint works! Content-Type: ${response.headers.get('Content-Type')}`);
                
                // Try to play from this source
                video.src = url;
                video.load();
                console.log(`   üé¨ Attempting to play from: ${url}`);
            }
        } catch (e) {
            console.log(`${index + 1}. ${url} - Error: ${e.message}`);
        }
    });
}

// AJAX function to load more detections
async function loadMoreDetections() {
    const loadMoreBtn = document.getElementById('loadMoreBtn');
    const currentPage = parseInt(loadMoreBtn.dataset.page);
    const totalPages = parseInt(loadMoreBtn.dataset.totalPages);
    
    if (currentPage >= totalPages) {
        loadMoreBtn.textContent = 'All detections loaded';
        loadMoreBtn.disabled = true;
        return;
    }
    
    loadMoreBtn.textContent = 'Loading...';
    loadMoreBtn.disabled = true;
    
    try {
        // Load all remaining pages
        const promises = [];
        for (let page = currentPage + 1; page <= totalPages; page++) {
            promises.push(
                fetch(`/videos/api/{{ video.id }}/detections?page=${page}&per_page=50`)
                    .then(response => response.json())
            );
        }
        
        const results = await Promise.all(promises);
        
        // Find the detection list container
        const detectionList = document.querySelector('.max-h-96.overflow-y-auto');
        if (!detectionList) {
            console.error('Detection list container not found');
            return;
        }
        
        // Append new detections
        let totalAdded = 0;
        results.forEach(result => {
            if (result.detections && Array.isArray(result.detections)) {
                result.detections.forEach((detection, index) => {
                    totalAdded++;
                    const detectionHtml = createDetectionItemHtml(detection, totalAdded + {{ detections|length }});
                    detectionList.insertAdjacentHTML('beforeend', detectionHtml);
                });
            }
        });
        
        loadMoreBtn.textContent = `Loaded ${totalAdded} more detections`;
        loadMoreBtn.style.display = 'none';
        
        console.log(`‚úÖ Loaded ${totalAdded} additional detections via AJAX`);
        
    } catch (error) {
        console.error('‚ùå Error loading more detections:', error);
        loadMoreBtn.textContent = 'Error loading detections';
        loadMoreBtn.disabled = false;
    }
}

// Helper function to create detection item HTML
function createDetectionItemHtml(detection, index) {
    const html = `
        <div class="detection-item p-3 border-b border-gray-100 hover:bg-gray-50 cursor-pointer transition-colors"
             data-detection-id="${detection.id}"
             data-timestamp="${detection.timestamp}"
             data-frame-number="${detection.frame_number || ''}"
             data-bbox-x="${detection.bbox_x}"
             data-bbox-y="${detection.bbox_y}"
             data-bbox-width="${detection.bbox_width}"
             data-bbox-height="${detection.bbox_height}"
             onclick="navigateToDetection(${detection.timestamp}, ${detection.id}, ${detection.bbox_x}, ${detection.bbox_y}, ${detection.bbox_width}, ${detection.bbox_height})">
            
            <div class="flex justify-between items-start">
                <div class="flex-1">
                    <div class="font-medium text-gray-900">PERSON-${String(index).padStart(4, '0')}</div>
                    <div class="text-sm text-gray-600">${detection.timestamp.toFixed(2)}s</div>
                    <div class="text-xs text-gray-500">
                        Confidence: ${(detection.confidence * 100).toFixed(1)}%
                    </div>
                    <div class="text-xs text-gray-400">
                        Box: ${detection.bbox_x},${detection.bbox_y} ${detection.bbox_width}√ó${detection.bbox_height}
                    </div>
                    ${detection.is_identified ? '<div class="text-xs text-green-600 font-medium">‚úÖ Identified</div>' : ''}
                </div>
                <div class="ml-2 flex flex-col space-y-1">
                    <button class="text-blue-600 hover:text-blue-800 text-sm font-medium"
                            onclick="event.stopPropagation(); navigateToDetection(${detection.timestamp}, ${detection.id}, ${detection.bbox_x}, ${detection.bbox_y}, ${detection.bbox_width}, ${detection.bbox_height})">
                        üéØ Go
                    </button>
                    <button class="text-purple-600 hover:text-purple-800 text-xs font-medium"
                            onclick="event.stopPropagation(); calibrateBoundingBoxes(${detection.id})"
                            title="AI calibrate this detection">
                        ü§ñ Cal
                    </button>
                </div>
            </div>
        </div>
    `;
    return html;
}

</script>
{% endblock %}